
{%@import macrodoc.jim%}
{%MACRO name="import" since={%RELEASE:ZURICH%}%}

{%@snip:check file=../../jamal-core/src/main/java/javax0/jamal/builtins/Import.java hash=a0f57c21%}

== Syntax

 {@import [top noCache isolate in global] imported_file.jim}

`import` opens a file and reads the content of the file interpreting as Jamal macro file.
Anything defined in that file will be imported into the scope of the current file.
In other words, importing a file happens in the same scope where the `import` macro is used.
As a consequence of that, if the macro opening and closing strings are redefined in the imported file, they will also change in the importing file.
Any user-defined macros defined in the top-level scope of the file will also be available.

Note that the top-level scope of the file may not be the same as the global scope.
If the importing happens

* from an included file,
* from inside a block,
* from inside a macro, or
* in scope that was started with a `begin` macro

then the "top-level-scope of the file" is the one, that contains the `import` macro.
If anything is defined into the global scope in the imported file, then those macros will eventually be in the global scope and available to anyone later.

The output generated by the imported file is discarded.

The syntax of the command is

`{@import file_name}`

{%fileNameExplanationFor/import%}

== `top`

The option `top` can be used along with the `import`.
In this case, a relative file name is relative to the main file that imports the other files.
It is not possible to step one or a few levels up in the import hierarchy.
The only two possibilities are to import relative to the current one or to the top level one.

Note, however, that using the option `[top]` does not change the scope of the imports.
The definitions will be exported to the importing scope.
This option only changes the base directory for the file name calculation.

NOTE: The option `top` makes it possible to create macro libraries that are local to a document.
Documentation may consist of several files across multiple directories.
There can be a global import file containing macros used by all different documents in the different directories.
In addition, there can be an import file in each directory that contains macros used only in that directory.
The documents in the directory can import the global import file and the local import file.
The global file, however, can not import the local file using the `top` option eliminating the need for the second import in the documents.

Because the textual output from the evaluation of the file is discarded, feel free to use text in the file to be imported as documentation.
There is no need to enclose such a text into a `{@comment ...}` macro.

{%DEFAULTOPEN/{%RELEASE:SZEGED%}/import%}

[NOTE]
====
If there is a need to change the macro opening and closing strings in the imported file, the recommendation is to reset these changes before the end of the file.
This way the imported file will not affect the importing file.
Also, when the imported file starts with the `{@` characters the importing process changes the macro opening and closing strings to `{` and `}` before the import and resets them after the import.
If there is a `sep` macro changing the macro opening and closing strings in the imported file, then the reset will go back one level only, essentially reversing the last `sep` macro use.
Assume that you have a file that uses the `[` and `]` characters as macro opening and closing strings.
This file imports a file that starts with the `{@` characters.
The imported file also uses `{@sep <>}` to change the macro opening and closing strings to `<` and `>`.
At the end of the file this is reset and now the macro opening and closing strings are `{` and `}`.

This only happens when the file importing the other file uses something other than the `{` and `}` characters as macro opening and closing strings.
If the importing file uses the `{` and `}` characters, then the imported file will be evaluated using the `{` and `}` characters as macro opening and closing strings just the normal way without setting and resetting the macro opening and closing strings.
In this case the `{@sep <>}` change the macro opening and closing strings and this change will be in effect in the importing file.
====

== `noCache`

Starting with version {%RELEASE:ZOLLIKOFEN%} the import macro has the option `noCache`.
{%noCacheExplanation%}

== `isolate` (boolean)

The release {%RELEASE:ROGACHEVO%} introduced the option `isolate`.
Using this option will process the imported file in a new processor.
It means that the macros defined in the importING file will not be available in the importED file.
The macros defined in the imported file will be available in the importing file after the import the same way as if the `isolate` option was not used.

== `in`

{%PAROP_IN/import%}

== `global` (boolean)

This option signals that the import should be registered on the global level.
It is useful when a file is imported in a local level, but it contains only global macro definitions.
In that case, there is no need to import it even at higher levels.

== `force` (boolean)

This option enables the forceful import of a file, even if a file with identical content has already been imported.

To prevent redundant imports, the `import` macro avoids executing the macros within the imported file if a file with the same hash code has been imported previously. This check is conducted at the same or higher levels than the current import. If the import occurs at a lower level, it has no impact because that level is already out of scope, along with any macros imported at that level, unless they are designated as global or exported. Utilizing hash codes for checks helps minimize memory usage by not storing the complete import files and effectively ensures that the same file is not imported more than once.

However, there are scenarios where importing a file with the same content is necessary. For example, consider a situation where there is a global import file within a complex directory structure, and a file in the directory above merely imports the same file. This pattern continues up to the top-level directory.

In such cases, to enforce the import, use the `force`, or `forced` parop.
It can also be activated globally through the `import$force` option.