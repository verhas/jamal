= Jamal Snippet Handling Macros
{%@import res:jamal.jim%}\
{%@import ../shared_text.jim%}\
{%@import ../RELEASES.jim%}\
{%@snip:collect from="src/main/java/"%}\
{%@snip:collect from="src/test/java/" exclude="Sample.java"%}\
{%#define lastUpdated={%@date yyyy-MM-dd HH:mm:ss%}%}\
{%#snip:define lastUpdated={%lastUpdated%}%}\
{%@define JAVA_DIR=src/main/java/javax0/jamal/snippet/%}
{%@define standardInput= The macro scans the input using the <<../README.adoc#argsplit,Standard Built-In Macro Argument Splitting>>.%}
{%@define alias(x)=(can be aliased as `x`)%}

Snippet handling macros help you to include information from program source code into the documentation automatically.
This macro package also includes some XML handling, string, and text formatting macros, which are usually used together with snippets.

When you document an application, there is a lot of information that changes by changing the source code.
These changes have to be followed in the documentation.
Some changes need manual editing.
Some changes can be automated.
When the program functionality changes, the changed documentation has to describe the new functionality.
We can hardly automate this change of documentation.
When some literal parameter also used in the document changes, then Jamal can automatically update the documentation.
A typical example is the version number of the application.
The documentation many times may refer to the latest version.

For example, if you want to use the latest version of Jamal Snippet macro as a dependency in a `pom.xml` file then you have to have the lines:

{%@snip:xml pom=pom.xml%}\
{%#define VERSION={%pom /project/version/text()%}%}\
[source,xml]
----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{%VERSION%}</version>
</dependency>
----

You see in the `README.adoc` file the actual version number converted from the `README.adoc.jam`.
The original file, however, contains

[source,xml]
----
{%@escape* ``{%@snip:xml pom=pom.xml%}\
{%#define VERSION={%pom /project/version/text()%}%}
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{%VERSION%}</version>
</dependency>``%}
----

The Jamal Snippet macros help you automate to insert actual, and transformed values, text fragments from

* any source code
* XML file
* properties files.

These small text pieces are called snippets.

When the `.jam` file gets processed, the snippets will automatically contain the source code's actual text.
This way, it is easier to keep your documentation up to date.

== Table of contents

. <<usage,Usage>>
. <<macros,Macros>>
[lowerroman, start=1]
.. <<snip_collect,`snip:collect`>>
.. <<snip_properties,`snip:properties`>>
.. <<snip_xml,`snip:xml`>>
.. <<xml_define,`xml:define`>>
.. <<xml_insert,`xml:insert`>>
.. <<snip_define,`snip:define`>>
.. <<snip_clear,`snip:clear`>>
.. <<snip,`snip`>>
.. <<snip_check,`snip:check`>>
.. <<snipList,`snip:list`>>
.. <<snipSave,`snip:save`>>
.. <<snipLoad,`snip:load`>>
.. <<trimLines,`trimLines`>>
.. <<untab,`untab`>>
.. <<range,`range`>>
.. <<Base64,`base64`>>
.. <<rot13,`rot13`>>
.. <<urlencode,`urlencode`>>
.. <<pos,`pos`>>
.. <<sort,`sort`>>
.. <<numberLines,`numberLines`>>
.. <<killLines,`killLines`>>
.. <<skipLines,`skipLines`>>
.. <<replace,`replace`>>
.. <<replaceLines,`replaceLines`>>
.. <<counter_define,`counter:define`>>
.. <<references,`references`>>
.. <<reflow,`reflow`>>
.. <<snipLine,`snip:line`>>
.. <<snipFile,`snip:file`>>
.. <<snipTransform,`snip:transform`>>
.. <<lineCount,`lineCount`>>
.. <<listDir,`listDir`>>
.. <<xmlFormat,`xmlFormat`>>
.. <<thinXml,`thinXml`>>
.. <<date,`date`>>
.. <<format,`format`>>
.. <<numbers,`numbers`>>
.. <<unicode,`unicode`>>
.. <<case,`case:lower`, `case:upper`, ...>>
.. <<file,`file`>>
.. <<directory,`directory`>>
.. <<Java,Java Macros>>
... <<java:class,`java:class`>>
... <<java:field,`java:field`>>
... <<java:method,`java:method`>>
... <<java:sources,`java:sources`>>
... <<java:classes,`java:classes`>>
... <<java:methods,`java:methods`>>
... <<java:fields,`java:fields`>>
... <<java:insert,`java:insert`>>
.. <<String,String Macros>>
... <<string:contains,`string:contains`>>
... <<string:quote,`string:quote`>>
... <<string:equals,`string:equals`>>
... <<string:startsWith,`string:startsWith`>>
... <<string:endsWith,`string:endsWith`>>
... <<string:reverse,`string:reverse`>>
... <<string:substring,`string:substring`>>
... <<string:length,`string:length`>>
... <<string:chop,`string:chop`>>
... <<shell:var,`shell:var`>>
... <<hashCode,`hashCode`>>
... <<memoize,`memoize`>>
... <<download,`download`>>
.. <<snip_update,`snip:update`>>
. <<kroki,Kroki>>
{%@counter:define id=chapter format=%d. %}
{%@counter:define id=macroChapter format=$roman. %}

[[usage]]
== {%chapter%}Usage

If you are using Jamal programmatically or from Maven then the dependency you have to add to your project is:

----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{%VERSION%}</version>
</dependency>
----

The macro classes are listed in the `provides` directive in the `module-info.java`; therefore, they are available for the Jamal processor when the JAR file is on the path (class or module).
There is no need to invoke the `use` command to get access to these macros.

[[macros]]
== {%chapter%}Macros
{%@define parameterized=
The first line following the macro identifier until the end of the line may contain parameters.
These parameters are parsed using the Standard Parameter Parsing as defined in link:{%@file ../documentation/PARAMS.adoc%}[PARAMS].
%}
[[snip_collect]]
=== {%macroChapter%}`snip:collect`
{%#snip:check file={%JAVA_DIR%}Collect.java hash=24342c7e%}
Since 1.7.4 option `onceAs`

This macro collects text snippets from files.
{%parameterized%}
The syntax of the macro is

[source]
----
{@snip:collect from="fileName" ...options}
----

`fileName` can be the name of a text file, or it can be a directory.
If the `fileName` is a text file, then the macro will collect the single file's snippets.
If the `fileName` is a directory, then the macro will collect the snippets from the files in that directory and from directories beneath recursively.

The file name is relative to the Jamal source, which contains the `snip:collect` macro.
The file name can start with `res:` or `https://`.
In these cases, the content of the file will be loaded from a resource or through the net respectively.

A snippet in a file is a series of lines that happen between

[source]
----
snippet name
----

and

[source]
----
end snippet
----

lines.

A special snippet containing only a single line can be specified preceding it with a line

[source]
----
snipline name
----

In this case there is no need for `end snippet` line.
This way

[source]
----
// snippet MY_CONSTANT_SNIPPET_NAME
  public static final MY_CONSTANT = "Hello World";
// end snippet
----

is the same as

[source]
----
// snipline MY_CONSTANT_SNIPPET_NAME
  public static final MY_CONSTANT = "Hello World";
----

[NOTE]
====
The only difference is that the first version will contain a line with a trailing `\n` at the end of the line.
The `snipline` version does not contain the trailing `\n`.
====

A snipline can also have a trailing `filter=regex` after the name of the snippet.
The rest of the line after the `filter=` is a regular expression that will be used to filter the line.
(Note that there is no space before or after the `=` character.)
The regular expression should have exactly one capturing group, and it must match the next line.
The capturing group will be used as snippet content.

For example

[source]
----
// snipline MY_CONSTANT_SNIPPET_NAME filter="(.*)"
  public static final MY_CONSTANT = "Hello World";
----

will store `Hello World` as the content of the snippet `MY_CONSTANT_SNIPPET_NAME`.
Unfortunately, it is easy to misread the line above and to think that the capture group will match the whole line.
However, the filter on the `snipline` is not a macro parameter.
It is processed in a different way.
The whole part following the `filter=` is part of the regular expression, including the `"` characters in the above example.

The possibility of `filter=` following the name of the snippet is a complimentary feature.
Cutting off a part of the line using regular expression can also be done where the `snip` macro references the snippet.
This complimentary feature exists to keep the filtering regular expression close to the line from which you want to cut a part off.

There can be extra characters before or after the `snippet name` and/or the `end snippet` strings.
The only requirement is that the regular expression `snippet\s+([a-zA-Z0-9_$]+)` can be found in the starting line and `end\s+snippet` in the ending line.

[NOTE]
====
The definition and matching criteria of the start and the end of the snippet are very liberal.
The reason for that is to ease in recognizing these in different files.
The regular expressions will find snippet start, and snippet ends in Java files, in XML, in Perl or Python code.
Essentially, you should not have a problem signaling the start, and the end of the snippet in any program code that allows you to write some form of a comment.

The disadvantage of this liberal definition is that sometimes it finds lines that accidentally contain the word snippet.
If you look at the source code in the file {%@file src/main/java/javax0/jamal/snippet/TrimLines.java%} you can see examples.
The comment mentions snippets, and there is a word eligible to be an identifier after `snippet`, and the parsing thinks that this is a snippet start.
Eventually, there is no `end snippet` on the lines following it, which is an error the snippet collection process recognizes.
(Up to 1.7.2. Later versions use this file as a snippet source; thus, it has 'end snippet'.)
Still, you do not receive an error message.

That is because the collection process only recognizes this error but does not throw an exception.
The exception is thrown only when you want to use the `snip` macro for an unterminated snippet.

The possible situation may even be more complicated because the accidental word following `snippet` in a comment may also be used in other files as a snippet identifier.
The collector, sooner or later, will find that definition, and it will assume that the one with the error was just an accidental comment and replaces the old with the correct, error-free snippet.
It is still okay when the snippet collection finds these two snippets in the opposite order.
If there is already a correct, error-free snippet collected and the collection finds an erroneous one of the same name, it ignores that.

This way, the collection and the use of the snippets ignores the accidental snippet definitions, but at the same time, it can detect the malformed snippets.

If you look at the {%@file src/main/java/javax0/jamal/snippet/TrimLines.java%} in version 1.7.3 or later, you can see that there is a `// snippet` line in the code.
Because there is also an accidental `snippet` line before it, the collection would not find this line.
Because of the previous `snippet` line, the real `// snippet` line becomes part of the previous snippet.
The `// snippet` line is preceded by an `// end snippet` line to avoid this.
Such a line out of a snippet is ignored, and in this case, it closes the accidental snippet.
====

As you can see, the regular expression contains a collection group, which Jamal uses as the name of the snippet.
For example, the code

{%@snip:collect onceAs="sample.Java" from="src/test/java/javax0/jamal/documentation/Sample.java"%}
{%@snip:collect onceAs="sample.Java" from="src/test/java/javax0/jamal/documentation/Sample.java"%}

[source]
----
// snippet sample
{%@snip sample%}\
// snippet end
----

defines a snippet that is named `sample`.
The snippets can be used later using the <<snip,`snip`>> macro.

The output of the `collect` macro is an empty string.

The macro behaviour can be altered using options.
These options are parsed using the Standard Parameter Parsing as defined in link:{%@file ../documentation/PARAMS.adoc%}[PARAMS].

{%#eval {%`@comment%}
{%#replaceLines replace="~.*?final\\s+var\\s+\\w+\\s*=\\s*scanner\\..*?\\(.*?\"(.*?)\".*~* `$1`~.*//\\s*~"
{%@snip collect_options%}
%}%}

If the parameter `start` or `liner` are defined, the value will be used as a snippet start matching regular expression.
They must have one collection group.

NOTE: We introduced this option to the `snip:collect` macro along with the Jamal doclet implementation.
When the individual documentation parts are processed in the same processor, the processing order is not guaranteed.
To refer to some snippets, you have to collect them.
To do that, you have to have the `snip:collect` in every JavaDoc, presumably using an imported file.
That collect macro should name the collection to avoid redefinition error.

[[snip_properties]]
=== {%macroChapter%}`snip:properties`
{%#snip:check file={%JAVA_DIR%}SnipProperties.java hash=0e8ee2e6%}
This macro will load properties from a "properties" file or an "XML" file.
The names of the properties will become the names of the snippets and the values of the snippets.

For example, the sample

{%sample/
{@snip:properties src/test/resources/javax0/jamal/snippet/testproperties.properties}
%}

{%#comment this output is evaluated because this is when the macro in the sample is evaluated
{%output%} but there is no output. The later examples use the snippets that this macro evaluation
was reading from the properties file.
%}\

will load the content of the file `javax0/jamal/snippet/testproperties.properties`, which is

[source]
----
{%@include ./src/test/resources/javax0/jamal/snippet/testproperties.properties%}
----

and thus using the `snip` macro, like

{%sample/
{@snip a}
%}

will result

{%#snip:define snipa={%output%}%}

{%@snip snipa
[source]
----
letter a
----
%}

If the file extension is `.xml`, the properties will be loaded as XML format properties.
For example, the same properties file in XML format looks like the following:

[source,xml]
----
{%@include ./src/test/resources/javax0/jamal/snippet/testproperties.xml%}
----

[[xml_define]]
=== {%macroChapter%}`xml:define`
{%#snip:check file={%JAVA_DIR%}Xml.java,{%JAVA_DIR%}AbstractXmlDefine.java hash=d0fe9949%}
This macro scans its input as an XML and assigns the parsed data to a "user-defined" macro.
The syntax of the command is:

[source]
----
{@xml:define macroName=xmlcontent}
----
{%@define XML_MACRO_USE=
The defined `macroName` macro can be used as an ordinary user-defined macro that accepts one, optional argument.
This user-defined macro evaluates in a particular way.
It uses the argument as an XPath expression and returns the value from the XML document that matches the argument.
If the XPath expression is missing then the whole XML content is converted to text formatted.
%}
{%XML_MACRO_USE%}

For example the `pom.xml` can be read using the following macro use:

{%sample/
{#xml:define pom={@include [verbatim]pom.xml}}\
{#define VERSION={pom /project/version/text()}}\
...
<version>{VERSION}</version>
...
%}

The result is:

{%output%}

[[snip_xml]]
=== {%macroChapter%}`snip:xml`
{%#snip:check file={%JAVA_DIR%}SnipXml.java,{%JAVA_DIR%}AbstractXmlDefine.java hash=c48d0f2a%}
This macro loads an XML file and assigns it to a "user-defined" macro.
The syntax of the command is

[source]
----
{@snip:xml macroName=xml_file.xml}
----

{%XML_MACRO_USE%}

For example, this document contains the following macros at the start:

{%sample/
{@snip:xml pom=pom.xml}\
{#define VERSION={pom /project/version/text()}}\
...
<version>{VERSION}</version>
...
%}

The result is:

{%output%}

which is the current version of the project as read from the `pom.xml` file.

[[xml_insert]]
=== {%macroChapter%}`xml:insert`
{%#snip:check file={%JAVA_DIR%}XmlInsert.java hash=57dcd8c6%}
This macro can modify an XML formatted user defined macro inserting content into the XML document.
It can also be used to insert an XML fragment into the XML document, which is the output of the whole processing.
This latter use is for the case when the Jamal file processed creates an XML file.
The syntax of the command is

{%sample/
{@xml:insert (options) xml_content}
%}

The options define the name of the xml formatted user defined macro the content should be inserted into as well as the xPath that defines the location of the insertion.

* `xpath` {%alias path%} defines the location in the original XML where to insert the content.

* `id`, {%alias to%} defines the name of the XML user defined macro which will be modified.
If this option is missing then the insertion will happen when the whole document processing is already finished.
In that case the target XML is the one, which is the result of the Jamal processing.
This is usable when the Jamal processing creates an XML as a result.
The insertions are done in the order of the `xml:insert` commands and after that the output will be the resulting XML formatted.

* `ifneeded` {%alias optional%} defines whether the insertion is optional.
If the location specified by the `path` already contains a tag with the given name, then the XML will not be modified.
Without this option a new child is appended having the name that may already be there.

* `tabsize` can specify the formatting tab size.
This makes only sense if the insertion happens to the final XML content of the processing.

The following example shows how to insert a new child into the XML document.

{%sample/
{@xml:define myXml=<xml>
<yml>babu</yml>
</xml>}\
{@xml:insert (to=myXml path=/xml) <zml>wuku</zml>}
{myXml}
%}

will result

{%output%}

The XML content is defined using the macro `xml:define`.
Later the content of this XML is modified using the macro `xml:insert`.
The content of the macro is converted to text and gets into the output when the name of the macro is used without the Xpath argument.

The following example demonstrates how the result of the processing can be modified.

{%sample/
<project>
{@xml:insert (path=/project ifneeded)<dependencies></dependencies>}
{@xml:insert (path=/project ifneeded)<plugins></plugins>}
{@xml:insert (path=/project ifneeded tabsize=2)<pluginManagement></pluginManagement>}
{@xml:insert (path=/project ifneeded)<dependencyManagement></dependencyManagement>}

{@xml:insert (path=/project/dependencies)
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{%VERSION%}</version>
</dependency>}
<plugins><plugin>
<artifactId>my-imaginary</artifactId>
<groupId>plugin</groupId>
<version>r65.1204-2021</version>
</plugin>
</plugins>

</project>
%}

will result


{%output%}

The insert macros in this example do not specify any `id`.
This means that all the modification is done to the XML, which is the whole document.
Also, the modification happens at the end of the processing.

The first four insertions are optional in the sense that they will modify the output if there is no such tag in the XML.
They make not much sense in a simple XML file, like this, but in a larger XML, where the different parts come from different includes it may make sense.
Such insertions ensure that these parts are inserted if they are needed by other insertions.
The first four lines could be in a separate file and included using the `include` macro to support pom structure.

In the example, the fifth insertion can only be executed successfully because the first one is there.
Without this there would be no `/project/dependencies` location in the XML file.
At the same time the second optional insertion for the `plugins` is ignored, because there is an explicit `plugins` tag in the content.
The fifth insertion adds a dependency to the `dependencies` tag.

[[snip_define]]
=== {%macroChapter%}`snip:define`
{%#snip:check file={%JAVA_DIR%}Snippet.java hash=20b912f2%}
You can use this macro to define a snippet.
Snippets are usually collected from project files, but it is also possible to define them via the macro `snip:define`.
For example,

{%sample/
{@snip:define mySnippet=
It is the snippet, which is defined inside the file and not collected from an external file.
}
{@snip mySnippet
is used here, and then the rest of the text is ignored}
%}

will result

{%output%}

Snippets are typically contain several lines and the leading spaces may be important.
To accommodate this when you define a snippet using this macro the spaces following the `=` sign up to, and including the new line will be skipped.
As you can see in the example above there is no new line before the sentence `It is the...`.
It is recommended to have a new line after the `=` character and start the snippet content on the next line.
If you start the snippet right after the ``=` character then the spaces between the first non-space characted and the `=` sign will be skipped.
For example:

{%sample/
{@snip:define mySnippet1=     It is the snippet,
which is defined inside the file and not collected from an external file.
}
{@snip mySnippet1
is used here, and then the rest of the text is ignored}
%}

will result

{%output%}

As you can see there are no spaces before the characters `It is the...`.

[[snip_clear]]
=== {%macroChapter%}`snip:clear`
{%#snip:check file={%JAVA_DIR%}Clear.java hash=060e1237%}
Calling this macro deletes all collected snippets from memory.
The result of the macro is an empty string.

[[snip]]
=== {%macroChapter%}`snip`
{%#snip:check file={%JAVA_DIR%}Snip.java hash=0a652943%}

You can use the `snip` macro to insert one or more snippets into the output.
There are three different ways to use the macro.

. insert a single snippet into the output with the full text of the snippet

. insert a part of the first line of a snippet into the output

. insert multiple snippets into the output.

In all of these cases the option `hash` or `hashCode` can be used to perform a consistency check.
It works exactly the same way as in the macro <<snip_check,`snip:check`>>.
The possibility to have this option eliminates the need to use the `snip` and the `snip:check` macros together.
Note, however, that it is not possible to check against the number of the lines in the snippet.
You can check only the hash code.

You can also use any of the options of the macro <<snipTransform,`snip:transform`>>.
The macro `snip` will automatically apply the transformations calling the macro `snip:transform`.

=== Use one snippet

The syntax for the first case is

[source]
----
{@snip snipped_id comment}
----

The result of the macro is the content of the snippet named `snipped_id`.
The macro reads the snippet identifier from the input, and it purposefully ignores the rest when used without the option `poly`.
The reason to have the rest of the input as the comment is to allow the Jamal file users to insert a description of the snippet.
You can manually copy the content of the snippet there, which helps the navigation in the source code, but at the same time, it may not be a problem if the copy gets outdated.
You can use the macro <<snip_update,snip_update>> to update the snippet's content in the Jamal source file.
Since that macro modifies the file you edit, you must use it with care.

Since the introduction of the Asciidoctor preprocessor and the WYSIWYG editing possibility of Asciidoc and Markdown files the importance of this feature has decreased.

=== Partial snippet

The second case uses only part of the snippet. (starting from Jamal version 1.7.2)

[source]
----
{@snip snipped_id /regular expression/}
----

If the "comment" following the snippet id starts with the `/` character, then the result of the macro is the first line of the snippet.
This line should match the regular expression, or an error is reported.
Also, the regular expression must be error-free and must have a match group.
The result of the macro will be the part of the first line of the snippet that matches the regular expression match group.
The typical use is when there is a constant defined in the code, and you want to reference the value of the constant.
In this case, you can add

[source,java]
----
// snipline snippet_id
...
----

line before defining the constant, and add a regular expression with one capturing group.
For example, you can have

[source,java]
----
// snipline defaultShellName
public static final String DEFAULT_RUBY_SHELL_NAME = ":rubyShell";
----

and the Jamal code

[source,text]
----
{#define defaultShellName={@snip defaultShellName /"(.*)"/}}\
----

to gauge out the string `:rubyShell` from the source code.

[NOTE]
====
It is also possible to specify the regular expression in the source code.
As it is documented in the section <<snip_collect,`collect`>>, the `snipLine` declaration may end with a `filter=regular expression` option.
====

When you check the snippet consistency using the option `hash` or `hashCode` the hash code of the whole snippet is calculated.
If there is any change in the snippet, even outside the first line, the hash code will be different and the snippet inclusion will purposefully fail.

=== Multiple Snippets

The third use is to insert multiple snippets into the output. (starting from Jamal 1.11.0)
In this case, the syntax is the following:

[source]
----
{@snip (poly) regular expression}
----

Note that there is no `/` around the regular expression.

The option `poly` has to be between `(` and `)` characters as usual in non-core built-in macros.

In this case, the macro collects and concatenates all snippets with regular expression matching names, and the value of the macro is the resulting text.
The snippets are sorted by their names before concatenation regardless of their appearance order in the file or files.

[NOTE]
====
This ordering is different from what you can achieve using AsciiDoc style snippet collecting.
When you do AsciiDoc style snippet collecting, you use the `tag::` name `[]` and `end::` name `[]` syntax to start and stop snippets.
A snippet can be started and stopped using the same name many times in the same file.
Following the style of AsciiDoc snippets, the collection process collects all those fragments into a single snippet.
The ordering is the same as the appearance order of the snippet fragments in the file.
The collection process does the concatenation.

When the `snip` macro is used with the option `poly`, the snippets are concatenated during the use.
The snippets may be collected from different files.
The order of the different snippets coming from separate files is not defined.
The snippets are sorted by their name before concatenation to guarantee a definite order.
It is recommended to name these snippets with a name and a number, like `my_snippet_1000`, `my_snippet_2000`, etc.
That way, the regular expression can be `pass:[my_snippet_\d{4}]`, and in case the ordering needs to be changed slightly, there is room to insert a new snippet between two already existing ones.
You may remember this technique from 40 years ago when BASIC program lines had to be numbered.
====

When used with the option `poly`, it is impossible to use any comment following the regular expression.
The whole text after the option till the macro closing string is interpreted as part of the regular expression.

When you check the snippet consistency using the option `hash` or `hashCode` the hash code of the whole text containing the snippets concatenated is calculated.
If there is

* any change in any of the snippets, or there is

* a new snippet included into the set,

* a snippet was deleted or renamed and is not included into the set any more,

* or in case the ordering of the snippets change,

* for any reason the concatenated set of snippets changes,

then snippet inclusion will purposefully fail.

=== Snippet Transformation

You can surround the snippet using the macro <<snipTransform,`snip:transform`>> transforming the output.
This is, however, such a usual case that the macro will automatically invoke the transformation.
To do this the macro `snip` will accept all the options of the macro `snip:transform` and will pass them to that.

[[snip_check]]
=== {%macroChapter%}`snip:check`
{%#snip:check file={%JAVA_DIR%}SnipCheck.java hash=af713bc8%}
You can use this macro to enforce consistency between the documented system and the documentation.
Using this macro will nudge the maintainer to check the relevant parts of the document when the documented code changes.
The macro itself will not update the documentation.
It will warn with an error if some part of the documentation needs update due to changed application code.
That way, the document may remain up-to-date, and you will not forget to update it.

To use the macro, you should first select some part of the code.
This part can be one or more snippets and whole source files.
You specify file names using the `file` or `files` option of the macro.
Snippets are specified using the `id` or `ids` option.
You can define one or more files and snippets at the same time.
The values are comma-separated.

[source,text]
----
{@snip:check hash=2a4ddeab580ad1fe8c95a id=snippet1,snippet2
    file=src/main/java/javax0/jamal/snippet/SnipCheck.java,src/test/java/javax0/jamal/snippet/TestSnipCheck.java%}
----

The macro `snip:check` calculates a hashcode of the snippet.
The hashcode can also be specified in the macro option `hash` or `hashCode`.

(These hex code above is made up, `TestSnipChek.java` does not even exist.)

If this hash code is the same as the one calculated, the programmer did not change the code in the snippet.
If the codes are different, then the macro will error.
It means that the snippet or file has changed, and the documentation has to follow the change.
When the documentation is updated, you should also update the hash code.

Nothing will stop you from updating the hash code without updating the documentation, though.
It takes discipline to keep the documentation up-to-date.
This macro only helps not to forget some parts.

The hash code calculated contains 64 hexadecimal characters.
You may notice that the examples above contain less.
The macro accepts if only a few characters of the hash code are present.
{%#assert:intEquals /6/{%@snip SnipCheck_MIN_LINE /(\d+)/%}/fix the number written out in the next line%}\
However, you have to specify at least six characters to ensure consistency.
You have one to the ten million chance to change the snippet and get the same hash using six characters.
It is reasonably safe, but you can go safer listing more characters.

It is a considerable practice to include some instruction into the error message helping the maintainer.
You can do that using the option `message`.
The string of this option will be part of the error message.
For example, this document includes some lines similar to the following ones.

[source]
----
{@snip:check hash=72415fa846e6f
             file={%JAVA_DIR%}SnipCheck.java
             message="Review the whole chapter of 'snip:check'"
}\
----

When you create the documentation of some code, you should follow the steps:

1. Enclose the parts of the code documented between `snippet NAME` and `end snippet`, or use complete files.

2. Insert the `{@snip:check hash="" id=NAME}` macro into the parts of the documentation where the pieces are documented.
Do not be afraid to copy and paste the macro.
In this case, copy-pasting is allowed, as the aim of this macro is to increase redundancy.

3. Run the macro processing.
It will eventually result in an error.
The error message will include the hash code.
Copy at least six characters to the macro, like `{@snip:check hash=af6ed3 id=NAME}`.
If you use more than one `snip:check` in your documents, using different parts of the hash code is recommended.
It will later help navigation when you search for the specific part of the document.

4. Rerun the macro processing.

When you update the documentation, and you get an error like

[source,text]
----
javax0.jamal.api.BadSyntaxAt: The file(src/main/java/javax0/jamal/snippet/SnipCheck.java)
hash is 'fa58557b.9735f98d.31c87ea5.074bd7f5.064ec63f.ec447a7e.58b8f969.958e5d4f' does not contain 'fa58557b9735f98k'.
'Review the whole chapter of 'snip:check'' at ../jamal-snippet/README.adoc.jam/435:14
----

then you have to do the following steps.

1. Look at the documentation around where the macro is.
The wrong hash code included in the error message will help you.
Use text search in the files looking for the hex code.
It should be reasonably unique.
Update the documentation to follow the change of the code part.

2. Update the hash code in the macro to the new value.

3. Rerun the macro processing.

[NOTE]
====
The error message contains the 64 character hex code as eight times eight characters dot-separated.
It helps you select a part of the code when you copy the new code into the documentation after the update.
It also helps you select different parts if you want to have more than one reference to the hash code.
The dots are not part of the code and are printed only for convenience and ignored when comparing.
You can use as many or as few dots in the hash code as you like.

The hash code is displayed using lower case hexadecimal characters, but you can use upper case or mixed case characters.
Before the check, the dots are removed, and the characters are converted to a lower case.
====

In some rare cases, you do not want to check all the modifications of the file.
You specify the option `lines` to check the number of lines in the snippet or file has not changed.
To do that, you can

[source,text]
----
{@snip:check lines=22 id=snippet1,snippet2}
----

and the macro will not error so long as long the snippet or the file contains exactly 22 lines.

You can specify both the `lines` and the `hash` together, but it does not make much sense.
The macro will check the hash value first.
If the hash value fails, the macro results an error.
If the hash value is correct, the file or snippet is identical, meaning it has the same number of lines as before.

{%#define JAMAL_SNIPPET_CHECK={%@snip SnipCheck_JAMAL_SNIPPET_CHECK /"(.+)"/%}%}
You can ask the macro `snip:check` to ignore its task defining the `{%JAMAL_SNIPPET_CHECK%}` system property to `false`.
It is handy when your documentation has many `snip:check` control, and the compilation of the documentation is don in the tests.
This would require the update of the hash code in the documentation whenever you make any small changes in the source code.
To avoid this you can

[source]
----
mvn clean verify -D{%JAMAL_SNIPPET_CHECK%}=false
----

which will compile your code on the development machine fine.
When you are finished with the adhoc changing, however, you have to update the documentation to reflect the changes in the code.

There is another way to force processing without error.
The macro `snip:check` has the option `snipCheckWarningOnly` (aliased as `warning`, `warningOnly`).
The name `snipCheckWarningOnly` is supposed to be used globally in the Jamal file via the `options` macro.
On the macro you will probably use `warning` or the more expressive `warningOnly`.
With this option the macro will not cause bad syntax error in case the check fails.
It will only log into the log file a warning message.

NOTE: Even when you use the `snipCheckWarningOnly` option, the macro will cause bad syntax when the hash code is too short, or there are some other errors.
It is only to supress hash code or line mismatch.

Using the option `warning` the error message will be sent to the log as a warning.
If you use the option `snipCheckError` (aliased as `error`) then the error message will be sent to the log as an error.
In this case, the error will not be suppressed.
You cannot use `warning` and `error` together.

[[snipList]]
=== {%macroChapter%}`snip:list`
{%#snip:check file={%JAVA_DIR%}SnipList.java hash=c7f80976%}
This macro lists the defined snippets.
{%parameterized%}

The list is represented as comma-delimited, which contains the names of the snippets.

There are four parameters the macro handles; all are optional:

* `name` {%alias id%} for the name of the snippet

* `file` {%alias fileName%} for the file name of the snippet

* `text` {%alias contains%} for the content of the snippet

* `listSeparator` can redefine the list separator. The default is the comma.

The first three parameters are interpreted as regular expressions.
If any missing or empty string, then the parameter is not taken into account.
If any of them is specified, only those snippets will be listed that match the expression.

The listing will filter the snippets to include only those into the list that

* the name of the snippet matches the parameter `name`, and

* the file name from which we harvested the snippet matches the parameter `file`, and

* at least one line of the snippet matches the parameter `text`.

The matching means that the regular expression should match part of the text.
If you want to match the full name, file name, or content line, you have to use a `^ ... $` format regular expression.

If all the parameters are missing, then the macro will list all the snippet names.

NOTE: The versions 2.2.0 and later do not include the snippets in the list which are errored.
These are snippets, which are not closed.
These are usually not snippets, but their start is recognized as a snippet start.
You can have the word `snippet` in your code followed by something that may look like a snippet start.
This is not an error in Jamal, only if you try to use any of these snippets.

[[snipSave]]
=== {%macroChapter%}`snip:save`
{%#snip:check file={%JAVA_DIR%}SnipSave.java hash=c073733d%}
This macro saves all the collected snippets to a file.
{%parameterized%}
The file name must be specified by the parameter `output`.
The general syntax of the macro is

[source,text]
----
{@snip:save options}
----

The usable options are the following:
{%@define REGEXTO=regular expression to match%}
* `name` {%alias id%} {%REGEXTO%} the name of the snippet

* `file` {%alias fileName%} {%REGEXTO%} the file name of the snippet

* `text` {%alias contains%} {%REGEXTO%} the content of the snippet

These parameters are interpreted as regular expressions.
If there is any missing or empty string, the parameter is not considered.
If any of them is specified, the macro will save only those snippets that match the expression.

* `output` should specify the name of the output file.
It is a mandatory parameter.

* `format` can specify the format of the output file.
The default value is `XML`.
The available formats are `XML` and nothing else.
This parameter is present for future compatibility and to provide readability if the command has to specify that the output is XML.

* `tab` {%alias tabSize%} can specify the number of spaces to use for indentation.
The default value is 4.
{%!@for $X in (NS,SNIPPETS,SNIPPET,TIME_STAMP,DATE_TIME,ID,FILE,LINE,COLUMN,HASH)=
{%#define saveLoad:$X={%@java:field (format=`$value`) javax0.jamal.snippet.SnipSave#$X%}%}%}

The saved XML file will use the namespace {%saveLoad:NS%}.
The top level element is {%saveLoad:SNIPPETS%}.

The {%saveLoad:SNIPPETS%} tag has the following attributes:

* {%saveLoad:TIME_STAMP%} is the time stamp {%@define WHEN=when the snippets were saved.%}{%WHEN%}

* {%saveLoad:DATE_TIME%} the date and time {%WHEN%}

The timestamp and the date/time values reflect the same value.
Programs reading the XML can use the timestamp value.
The human-readable date-time value is for the human reader.
Currently, none of these values are used by Jamal.

The elements below the {%saveLoad:SNIPPETS%} tag are {%saveLoad:SNIPPET%} tags.
Every {%saveLoad:SNIPPET%} tag has the following attributes:

* {%saveLoad:ID%} id the identifier of the snippet.
When this XML is loaded, <<snipLoad,`snip:load`>> will use this identifier to load the snippet.

* {%saveLoad:FILE%} the file the snippet was defined in.
When this XML has loaded, this file name will be restored so that the snippet will look like one loaded from this file.

* {%saveLoad:LINE%} is the line number in the file where the snippet starts.
When this XML is loaded, this line number will be restored so that the snippet will look like one loaded from this line from the specified file.

* {%saveLoad:COLUMN%} is the column where Jamal initially loaded the snippet from.
This value is usually `1` since snippets are multi-lined strings and do not contain fractional lines.
The snippet will look like one loaded from this column from the specified line when this XML is loaded.

* {%saveLoad:HASH%} contains the hash value of the snippet.
This value is calculated precisely as the hash value in the <<snip_check,`snip:check`>> macro.
When the <<snipLoad,`snip:load`>> macro reads the XML file, it compares the hash value calculated from the snippet's text with the hash value.
It is an error if the hash values do not match.
In that case, the snippet loading terminates, and no more snippets are loaded from the XML file.
The snippets already loaded will stay put.
Note, however, that you are allowed to delete the hash attribute from the XML file using an editor of your choice.
In that case, no check is performed.

The text of the snippet is the content of the {%saveLoad:SNIPPET%} tag.
It is saved as a `CDATA` section(s).

[[snipLoad]]
=== {%macroChapter%}`snip:load`
{%#snip:check file={%JAVA_DIR%}SnipLoad.java hash=bb0fe0aa%}
This macro can load the snippets from a file, which was saved by <<snipSave,`snip:save`>>.
{%parameterized%}
The file's name has to be specified by the parameter `input`.
The general syntax of the macro is

[source,text]
----
{@snip:load options}
----

The usable options are the following:

* `name` {%alias id%} {%REGEXTO%} the name of the snippet

* `file` {%alias fileName%} {%REGEXTO%} the file name of the snippet

* `text` {%alias contains%} {%REGEXTO%} the content of the snippet

These parameters are interpreted as regular expressions.
If there is any missing or empty string, the parameter is not considered.
If any of them is specified, the macro will load only those snippets that match the expression.

* `input` should specify the name of the input file.
It is a mandatory parameter.

* `format` can specify the format of the input file.
The default value is `XML`.
The available formats are `XML` and nothing else.
This parameter is present for future compatibility and to provide readability if the command has to specify that the input is XML formatted.

The XML file format has to be the same as the one used by the <<snipSave,`snip:save`>> macro.
It has to use the same namespace and tags.
The content of snippets must be in a CDATA section(s).

The {%saveLoad:TIME_STAMP%}, and {%saveLoad:DATE_TIME%} attributes of the tag {%saveLoad:SNIPPETS%} may be missing and are ignored during reading.
The attributes of the {%saveLoad:SNIPPET%} tags are mandatory except the {%saveLoad:HASH%} attribute.
If the {%saveLoad:HASH%} attribute is present, the macro will check its value against the content of the snippet.
It guarantees the snippet integrity.
If the tag is missing, the check is skipped.

Any tag can have any extra attributes.
Extra attributes are ignored.
If you want to change something in the XML file and edit some snippet code temporarily, you can rename the tag {%saveLoad:HASH%} to `_hash`, for example.

[[trimLines]]
=== {%macroChapter%}`trimLines`
{%#snip:check file={%JAVA_DIR%}TrimLines.java hash=e8aed8bc%}
This macro can cut off the unneeded spaces from the start and end of the lines.
{%parameterized%}

When you include a code fragment in the documentation as a snippet, the lines may have extra spaces at the start.
It is the case when the fragment comes from a code part somewhere in the middle of a tabulated structure.
This macro can remove the extra spaces from the start of the line keeping the relative tabulation of the lines.
The code formatting remains the same as the source code, but the macro will align the code sample to the left.

The syntax of the macro is:

[source]
----
{@trimLines ...

  possible
    multiple lines
}
----

For example:

{%untrimmedSample/
{@trimLines
  k
   a
   b
 c
}
%}

will result

{%untrimmedOutput%}

The lines to be trimmed should start on the line following the name of the macro.
The characters following the macro name to the end of the line are parsed for options.
Options currently are:

* `margin` can specify the minimum number of spaces that appear in front of every line.
You can even insert extra spaces in front of the lines while keeping the tabulation using this option.

* `trimVertical` is a boolean parameter to remove the new line character from the sample's start and end.
It eliminates the leading and trailing empty lines.

* `verticalTrimOnly` {%alias vtrimOnly%} instructs the macro to do only the vertical trimming.
If this option is defined, there is no need to define `trimVertical` also.

The macro can also delete the empty lines from the start and the end of its input if the option `trimVertical` is set.
For example

{%untrimmedSample/
{#trimLines
{@options trimVertical}



  k
   a
   b
  c


}
%}

will result

{%untrimmedOutput%}

[[untab]]
=== {%macroChapter%}`untab`
{%#snip:check file={%JAVA_DIR%}Untab.java hash=896e2f2e%}

The syntax of the macro is:

{%sample/
{@untab tabSize=8
multiple line of
    text with \t tab characters
}
%}

This macro replaces the tab characters in the input with spaces.
Each tab will be replaced with one or more spaces so that the alignment of the lines is preserved.
The tab stop is 8 by default, but it can be set to any value using the options `tabSize`.
This option has two aliases `tab` and `size`, which you can also use as macro parameters.
However, only `tabSize` is recognized as a macro if defined outside or inside the `untab`.
With that you can set the tab stop globally for all the snippets:

{%sample/

{@define :tabSize=8}
...

{@untab ... tabSize is defined as a global macro

  possible
    multiple lines
}
%}

{%@comment we need to have a separate file edited using VI or some other tab-friendly editor%}
For example:
{%@snip:check id=untabSample,untabSampleOutput hash=3ea1ff00 message="Check the untab sample if it is still okay!"%}
[source,text]
----
{%@define TRANSFORMATIONS=actions=replace,trim replace="/\"//" replace=/\\n// replace=/\+//%}
{%#snip ({%TRANSFORMATIONS%}) untabSample%}
----

will be converted to

[source,text]
----
{%#snip ({%TRANSFORMATIONS%}) untabSampleOutput%}
----


[[range]]
=== {%macroChapter%}`range`
{%#snip:check file={%JAVA_DIR%}RangeMacro.java hash=005a0ae6%}

This macro can filter lines of its input by a range of numbers.
The syntax of the macro is:

{%sample/
{@range lines=1..3,5..7;..1,0

lines
}
%}

The macro has an alias `ranges` that you are free to use in case the plural form is more readable.
The option `lines` cannot be used in singular, but it can also be aliased as `range` or `ranges`.

The format and the meaning of the option `lines` is exactly the same as the option of the same name in the core `import` macro.

{%TEXT:RANGE%}

[[Base64]]
=== {%macroChapter%}`base64` encode and decode
{%#snip:check file={%JAVA_DIR%}Base64.java hash=78c1b71b%}

There are two macros that can encode and decode the input using the Base64 algorithm.
The encoding macro is called `base64`.
It also has an alias `base64:encode`.

The decoding macro is named `base64:decode`.

By default, the macros trim the input removing the spaces from the start and from the end.
If you need to encode a string that contains spaces you can use the option `quote`.
In this case, the string has to be quoted.
Any character can be used as quoting character except space and the same character should be used at the start and at the end of the string.
The option `quote` can be used with the decoding macro as well to provide coherent use, although there is not much use of the option in this case.


{%sample/
{@base64:encode This is a test}
%}

will result in

{%output%}

and

{%sample/
{@base64:decode VGhpcyBpcyBhIHRlc3Q=}
%}

will result in

{%output%}

If you need a space before the text also encoded you should write

{%sample/
{@base64:encode (quote) " This is a test"}
%}

resulting in

{%output%}

and again the reverse:

{%sample/
>>{@base64:decode (quote) "IFRoaXMgaXMgYSB0ZXN0"}<<
%}

will result in

{%output%}

As the `>>` shows that the space is also decoded.

Both then encoding and the decoding macro can have the option `url`.
In this case, URL safe encoding is used.
The encoding macro will also handle the option `compress`.
Using this option, the string is first compressed before encoding.

NOTE: There is no option to decode the compressed string.
This option was developed to support link:https://docs.kroki.io[Kroki] service GET requests.

With these options, you can encode the following string:

{%@define KROKI_SAMPLE=
image::https://kroki.io/plantuml/svg/{@base64 (compress url)
skinparam ranksep 20
skinparam dpi 125
skinparam packageTitleAlignment left

rectangle "Main" {
(main.view)
(singleton)
}
rectangle "Base" {
(base.component)
(component)
(model)
}
rectangle "<b>main.ts</b>" as main_ts

(component) ..> (base.component)
main_ts ==> (main.view)
(main.view) --> (component)
(main.view) ...> (singleton)
(singleton) ---> (model)
}[]
%}

{%sample/{%KROKI_SAMPLE%}%}

which will result in

{%output%}

{%#killLines pattern="source|----"
{%output%}%}


[[rot13]]
=== {%macroChapter%}`rot13`
{%#snip:check file={%JAVA_DIR%}Rot13.java hash=2346fc70%}

This macro calculates the ROT13 transformation of the input.
For example

{%sample/
{@rot13 ROT13 is a simple letter substitution cipher
that replaces a letter with the 13th letter after it in the alphabet.
ROT13 is a special case of the Caesar cipher which
was developed in ancient Rome.}
%}

will result in

{%output%}

Rot13 encoding is not a strong encryption algorithm.
It can easily decrypt by the reader visiting the site http://rot13.com/
The main use is to provide some kind of obfuscation for the text that requires some effort to decipher.
For example, your document asks a question to the reader, and you also give the answer in ROT13.
The reader will not be able to read the answer, only when they put effort deciphering.

I usually use this macro to write a __"Do not edit this file, it is generated"__ already rot13 encoded in the `.jam` file.
This way the source file you edit will contain an unreadable rot13 encoded text, but the generated file contains the readable warning.

[[urlencode]]
=== {%macroChapter%}`urlencode`

This macro will URL encode its input.
The format of the macro is

{%sample/
    http://my.precious.com/what?{@urlencode (charset=UTF-8) query=" this is a quoted string"}
%}

which, in this example will result

{%output%}

The macro has one option parameter:

* `charset` (alias `cs`) - the character set to use for encoding. The default is `UTF-8`.


[[pos]]
=== {%macroChapter%}`pos`
{%#snip:check file={%JAVA_DIR%}Pos.java hash=d8ad4ce0%}

This macro will result the

* file name,
* line number, or
* column number

of the actual location.
The simple way using the macro is, for example

{%sample/
{@pos.file}:{@pos.line}:{@pos.column}
%}

will result

{%output%}

The version introduced after 1.12.4 also handles options between `(` and `)`:

{%#eval {%`@comment%}
{%#replaceLines replace="~.*?final\\s+var\\s+\\w+\\s*=\\s*Params\\..*holder\\(null,(.*?)\\).*~* $1~.*//\\s*~" replace="~\"(\\w)~`$1~(\\w)\"~$1`~"
{%@snip pos_options%}
%}%}

The actual file name and line number may not be the one where the macro is in the file.
It is where the macro `pos` is evaluated.
This behaviour may result that the line number or column is not accurate when the macro is not evaluated from the top level context.
It is also known that Jamal increases the line numbers in some cases extensively during maco evaluation.
This is a known bug resulting in the line number larger than the actual.

[[sort]]
=== {%macroChapter%}`sort`
{%#snip:check file={%JAVA_DIR%}Sort.java hash=4a1b694b%}
This macro returns the input sorted.
The default behaviour is to sort the lines of the input alphabetically.
For example

{%sample/
{@sort
beta
zeta
alpha}
%}

will result the output

{%output%}

To have more flexibility you can use parameters on the first line of the input to specify collating order, record separator and so on.

The options are:

{%#replaceLines replace="/^.*holder\\(.*?\"(.*?)\"\\).*$/* `$1`/" \
replace="/\",\\s*\"/`, alias `/" replace="~//~~"
{%@snip sort_options%}%}

The input is treated as a list of textual records separated by strings.
The separator can be defined as a regular expression.
The default value is `\n`, which means that the individual lines will be the records.
An example, different from the default record separator:

{%sample/
{@sort separator=### join=### pattern="key=(.*)" numeric
key=1
this
is one record
###
key=03
This is the second
record, multiple lines
###
key=2
This gets into the middle
}
%}

will result

{%output%}

This sample uses a pattern to select the key, a non-default joining string, and it also specifies that the sorting has to be numeric.

The next example specifies the sorting when the collating order is specified.
Here the collating order is Hungarian.
{%sample/
{@sort locale=HU
Cukor
Csiga
Csszr
Czucor
Abrak
}
%}

It will result the following order:

{%output%}

Note that the special character `` is properly used as it follows the letter `a` in the Hungarian collation order.
Also, the `cs` is a compound sound following the letter `c` in Hungarian and that way `Czucor` comes before `Csszr` or `Csiga`, whatever they mean.


The next example uses semantic versioning.

{%sample/
{@sort collator=semver
1.0.0-alpha
1.0.0-alpha.beta
1.0.0-beta
1.0.0-beta.2
1.0.0-alpha.1
1.0.0-beta.11
1.0.0-rc.1
1.0.0
}%}

It will result the following ordering:

{%output%}

NOTE: The sample above does not specify the fully qualified class name of the collator.
The macro `sort` implements a little shortcut for the semantic versioning collator provided in the Jamal source code.
If you write `semver` (case insensitive) instead of the fully qualified domain name, it will automatically use the `javax0.jamal.snippet.SemVerCollator` class as collator.

[[numberLines]]
=== {%macroChapter%}`numberLines`
{%#snip:check file={%JAVA_DIR%}NumberLines.java hash=9080a6ce%}
This macro can put numbers in front of the lines, sequentially numbering them.
{%parameterized%}

The syntax of the macro is

[source]
----
{@numberLines options
     ..
     ..
     ..
}
----

By default, the numbering of the lines starts with one, and every line gets the next number.
For example

{%sample/
{@numberLines
this is the first line
this is the second line
this is the third line
}
%}

will result
{%#snip:define numberedLines1={%output%}%}\

{%@snip numberedLines1
[source]
----
1. this is the first line
2. this is the second line
3. this is the third line
----
%}

The macro will insert the number with a `.` (dot) after the number and space.

The parameters `start`, `step`, and `format` can define different start values, step values, and formats for the numbers.
For example

{%sample/
{#numberLines start=3 step=2 format=" %03d::"
this is the first line
this is the second line
this is the third line
}
%}

will result
{%#snip:define numberedLines2={%output%}%}\

{%@snip numberedLines2
[source]
----
003::this is the first line
005::this is the second line
007::this is the third line
----
%}

The standard Java method `String::format` will format the number using the formatting string.
Any illegal formatting will result in an error.

[[killLines]]
=== {%macroChapter%}`killLines`
{%#snip:check file={%JAVA_DIR%}KillLines.java hash=c3fccc9d%}
This macro deletes, or keeps the selected lines from its input.
{%parameterized%}

The format of the macro is

[source]
----
{@killLines parameters

 ...

}
----

or

[source]
----
{@filterLines parameters

 ...

}
----

NOTE: We recommend using the `filterLines` and `pattern` aliases when you want to keep the lines matching the pattern and delete the other lines. In other cases the `filterLines` and `kill` or `killLines` and `kill` or `pattern` aliases can be used. The `killLines` and `keep` aliases together are not recommended.

The default behavior of the macro is to delete the empty lines.
In that case, it removes all lines that contain only spaces or nothing at all.

The parameter macro `pattern` may define a regular expression to select the lines.

For example:

{%sample/
{#killLines pattern=^\s*//
/* this stays */
// this is some C code that we want to list without the
// single line comments

#define VERSION 1.0 //this line also stays put
int j = 15;
}
%}

creates the output

{%output%}

If the option `keep` is used then the lines that match the pattern are kept and the other lines are deleted.


{%sample/
{#killLines pattern=^\s*// keep
/* this stays */
// this is some C code that we want to list without the
// single line comments

#define VERSION 1.0 //this line also stays put
int j = 15;
}
%}

creates the output

{%output%}

In this case only the comment lines remained that start with `//` at the start of the line.

[[skipLines]]
=== {%macroChapter%}`skipLines`
{%#snip:check file={%JAVA_DIR%}SkipLines.java hash=da20c169%}
You can use this macro to skip lines from the snippet.
{%parameterized%}

It is similar to <<killLines,`killLines`>> but this macro deletes ranges of lines instead of individual lines.
The macro uses two regular expressions, named `skip` and `endSkip`.
When a line matches the line `skip`, the line and the following lines are deleted from the output until a matching `endSkip`.
The macro also deletes the lines that match the regular expressions.

For example,

{%sample/
{@skipLines
this line is there
skip this line and all other lines until a line contains 'end skip' <- this one does not count
this line is skipped
this line is skipped again
there can be anything before 'end     skip' as the regular expression uses find() and not match()
there can be more lines
}
%}

will result
{%#snip:define skipLines1={%output%}%}\

{%@snip skipLines1
[source]
----
this line is there
there can be more lines
----
%}

You can also define the regular expressions defining the parameters `skip` and `endSkip`.
For example,

{%sample/
{#skipLines {@define skip=jump\s+starts?\s+here}{@define endSkip=land\s+here}
this line is there
jump start here
this line is skipped
this line is skipped again
land                 here
there can be more lines
}%}

will result
{%#snip:define skipLines2={%output%}%}\

{%@snip skipLines2
[source]
----
this line is there
there can be more lines
----
%}

It is not an error if there is no line matching the `endSkip`.
In that case, the macro will remove all lines starting with a string matching the `skip` from the output.
There can be multiple `skip` and `endSkip` lines.
The `skip` and `endSkip` lines cannot be nested.
When there is a match for a `skip`, any further `skip` is ignored until an `endSkip`.

[[replace]]
=== {%macroChapter%}`replace`
{%#snip:check file={%JAVA_DIR%}Replace.java hash=5f3f71c2%}
The macro `replace` replaces strings with other strings in its input.
{%standardInput%}

It uses the first argument as the input, and then every following argument pairs as search and replace strings.
For example:

{%sample/
{@replace /the apple has fallen off the tree/apple/pear/tree/bush}
%}

will result:
{%#snip:define replace1={%output%}%}\

{%@snip replace1
[source]
----
the pear has fallen off the bush
----
%}

If the option `regex` is active, then the search string is treated as regular expressions, and the replace string may also contain replacement parts.
For example,

{%sample/
{#replace {@options regex}/the apple has fallen off the tree/appl(.)/p$1ar/tree/bush}
%}

will result in the same output
{%#snip:define replace2={%output%}%}\

{%@snip replace2
[source]
----
the pear has fallen off the bush
----
%}
but this time, the replace used regular expression substitution.

[[replaceLines]]
=== {%macroChapter%}`replaceLines`
{%#snip:check file={%JAVA_DIR%}ReplaceLines.java hash=b2558440%}
This macro replaces strings in the input.
{%parameterized%}

It works similarly to the macro <<replace,`replace`>>.
The difference is that the `replaceLine`

* is always works with regular expressions, and

* it works on the individual lines of the input in a loop.

The difference is significant when you want to match something line by line at the start or the end of the line.
For example,

{%sample/
{@define replace=/^\s+\*\s+//}
{@replaceLines
* this can be a snippet content
* which was collected
* from a Java or C program comment
}
%}

will result
{%#snip:define replaceLines1={%output%}%}\

{%@snip replaceLines1
[source]
----
* this can be a snippet content
* which was collected
* from a Java or C program comment
----
%}

The searched regular expressions and the replacement strings have to be defined in the parameter `replace`.
This parameter can be defined inside the `replaceLines` macro.
The macro scans the value of the parameter `replace` using the <<../README.adoc#argsplit,Standard Built-In Macro Argument Splitting>>.

It is usually an error when no lines are replaced in a snippet.
Use the parameter`detectNoChange` to detect this.
If this boolean parameter is `true`, the macro will error if it changes no line.

[[counter_define]]
=== {%macroChapter%}`counter:define`
{%#snip:check file={%JAVA_DIR%}CounterMacro.java,src/main/java/javax0/jamal/snippet/Counter.java hash=ec5335f2%}
This macro defines a counter.
The counter can be used like a parameterless user-defined macro that returns the actual formatted value of the counter each time.
The actual value of the counter is modified after each use.
The format of the macro is

[source]
----
{@counter:define id=identifier}
----

The value of the counter starts with 1 by default and is increased by 1 each time the macro is used.
For example,

{%sample/
{@counter:define id=c} {c} {c} {c}
%}

will result

{%output%}

You can define the `start`, and the `step` value for the counter as well as the `format`.
For example,

{%sample/
{#counter:define id=c start=2 step=17} {c} {c} {c}
%}

will result

{%output%}

The format can contain the usual `String.format` format string.
In addition to that, it can also contain one of the `$alpha`, `$ALPHA`, `$roman` or `$ROMAN` literals.

{%@define alphaRomanReplace($format,$by,$number)={%@ident%}\
* `$format` will be replaced by $by for 1, 2, ... , $number counter values.%}\
{%alphaRomanReplace/$alpha/`a`, `b`, ... , `z`/26%}
{%alphaRomanReplace/$ALPHA/`A`, `B`, ... , `Z`/26%}
{%alphaRomanReplace/$roman/the lower case roman numeral format/3999%}
{%alphaRomanReplace/$ROMAN/the upper case roman numeral format/3999%}

It is an error
{%@define errorMessage($format,$number)={%@ident%}\
* if either `$format` or `{%@case:upper $format%}` is used in the format, and the value is zero, negative, or larger than $number%}
{%errorMessage /$alpha/26%}, or
{%errorMessage /$roman/3999%}.

In some applications the number 4 is depicted as `IIII` instead of `IV` when using roman numerals.
You can see such use typically on some clock faces.
If you want to use this notation you can use the option `IIII` (all capital).
The use of this option makes only sense when you also specify the `$roman` or `$ROMAN` in the format.
The macro does not check this.

Examples:

{%sample/
{@counter:define id=h format=$roman IIII}{h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h}
%}

will result in

{%output%}


{%sample/
{#counter:define id=cFormatted{@define format=%03d.}}{cFormatted} {cFormatted} {cFormatted}
{#counter:define id=aFormatted{@define format=$alpha.}}{aFormatted} {aFormatted} {aFormatted}
{#counter:define id=AFormatted{@define format=$ALPHA.}}{AFormatted} {AFormatted} {AFormatted}
{#counter:define id=rFormatted{@define format=$ROMAN.}{@define start=3213}}{rFormatted} {rFormatted} {rFormatted}
{#counter:define id=RFormatted{@define format=$ROMAN.}{@define start=3213}}{RFormatted} {RFormatted} {RFormatted}
%}

The output will be

{%#snip:define counter3=
{%output%}%}\

{%@snip counter3
[source]
----
001. 002. 003.
a. b. c.
A. B. C.
MMMCCXIII. MMMCCXIV. MMMCCXV.
MMMCCXIII. MMMCCXIV. MMMCCXV.
----
%}

Sometimes you want to use the current value of the counter multiple times.
It is possible to define a macro using the counter and then use the macro referring to the value.
For example the following code

{%sample/
{@counter:define id=c}{c} {#define second={c}}{second} {second} {c}
%}

will result

{%output%}

The implemented counters, however provide a simplified approach for this.

{%sample/
{@counter:define id=c}{c} {c} {c last} {c}
%}

will have the same output:

{%output%}

In this case we used the word `last` as an argument to the counter macro `c`, which instructs the macro to return the last value without increment.

Sometimes you want to refer to a value of the counter much later, when the counter was already increased multiple times.
In that case you can still use the `define` as used above, but the macro counter also gives a shortcut to do that.
If you write

{%sample/
{@counter:define id=m}{m} {m -> secondChapter} {m} {m} is still {secondChapter}
%}

will result

{%output%}

The user defined macro `m`, which is a counter interprets the argument and create a new user defined macro named `secondChapter`.
The value of this user defined macro will be the same as the actual value of the counter.

[NOTE]
====
The `-` character before the `>` is a macro parameter separator, and the macro itself checks only the `>` character.
It means that you can use `.>`, `+>` or `/>` or any other non-alphanumeric first character in front of the `>`.
It is recommended to use the `-` or `=` for readability reasons.
====

[[references]]
=== {%macroChapter%}`references`

From time to time, there may be a need to have a reference to a part of the text that is defined later.
Macros, by their nature, cannot be used before they are defined.
You cannot reference a section or chapter number before the section or chapter is defined.
The macros provide powerful tools to overcome this limitation in many different ways.
For example, you can define the chapter titles and numbering at the start of the document and then reference these macros at the place where the chapters start.
The problem with this approach is that it separates parts of the document that belong together.
It is 100% against the philosophy of Jamal.

The `ref` and `references` macros give a different solution to this problem.
These macros help to save the values of selected macros to an external file.
Rendering the document the second time the file is read back and the macros are defined.

Typically, you use the macro `references` at the start of the file to define the reference file.
After that you can use the `ref` (or `reference` full name, but singular) to add specific macros to the set to be saved.

{%sample/
{@references file=sample.jrf}
{@ref a}
This is defined later, but can be used here: {a}
{@define a=The value of a}
%}

will result in

{%output%}

The macro `references` has two parameters:

* `file` can specify the file name to be used to save the references.
The default file name is `{%@snip REF_JRF%}`.
* `holder` is the name of the macro that will hold the list of macros to be saved.
The default name is `{%@snip XREFS%}`.

Using these options you can separate the references of different files and even in the same directory.
You can also save multiple set of references from a single document.

When using the macro `ref` you can specify the name of the macro to be saved.
Following it by a `>` sign, you can specify the name of the holder macro, where you want the reference saved.

{%sample/
{@references file=sample.jrf holder="otherRefs"}
{@ref a > otherRefs}
This is defined later, but can be used here: {a}
{@define a=The value of a}
%}

will result in

{%output%}

When using these macros, the rendering has to run twice.
The macros loaded by `reference` will always have the value that they had at the end of the previous execution.
It is your responsibility to write macros that are stable, having values independent of the previous execution.
Following the version {%RELEASE:MANAUS%}, the macro also signals an error if the macros change between processing.

When the rendering runs the first time, or the reference file was deleted, the macros are not defined.
To avoid errors the `?` can be used in front of the macro names defined later.
This will result in an empty string when the macro is used.

Another possibility is to use the `ref` macro before the first use of the referenced macro.
This macro will define the macro with the literal text `UNDEFINED` if the macro is not defined.

[[reflow]]
=== {%macroChapter%}`reflow`
{%#snip:check file={%JAVA_DIR%}Reflow.java hash=7521ef23%}
This macro reflows the content.
{%parameterized%}

The default behavior is to remove all single new-line characters replacing them with spaces.
That way, the lines will extend without wrapping around, and double newlines will separate the paragraphs.

For example:

{%sample/
{@reflow
The
short
lines
will
be put into a single line.

Empty lines are paragraph limiters.




Multiple empty lines are
converted to one.}
%}

The output will be

{%output%}

If the parameter `width` specifies a positive integer number, the macro will use it to limit the length of the lines.
For example

{%@define reflowSample=0123456789|
The
long
lines
will
be broken into words.

Empty lines are paragraph limiters.%}

{%@define REFLOW_WIDTH=10%}
{%sample/
{@reflow width={%REFLOW_WIDTH%}
{%reflowSample%}
}
%}

The output will be

{%output%}

The lines are collected and broken so that none of the lines is longer than {%REFLOW_WIDTH%}.
In some cases, limiting is not possible.
When the width is too small but still positive, some words may be longer than the given width.

{%@define REFLOW_WIDTH=1%}\
For example, setting the width to `{%REFLOW_WIDTH%}`, reflow will cut the lines into words, but it will not break the individual words.

{%sample/
{@reflow width={%REFLOW_WIDTH%}
{%reflowSample%}
}
%}

The output will be

{%output%}


The `width` parameter can be a macro option as well as a macro.
For example

{%sample/
{#reflow {@define width={%REFLOW_WIDTH%}}
{%reflowSample%}
}
%}

will have the same result as:

{%output%}

Setting the `width` to any non-positive value will remove the limit from the line length.
You may use this to override a globally set `width` macro.

[[snipLine]]
=== {%macroChapter%}`snip:line`

The macro `snip:line` results in the starting line number of the snippet in the file where the snippet is defined.
For example, if the snippet `hubbaba` was collected from a file with the `snippet hubbaba` on line 5, the macro will return 6.
The returned number counts the lines at the start of the file with one, and it is the line, which is the first line of the snippet following the snippet signaling line.

In this document, we use different snippets collected from the Java files of the snippet library.
One of the snippets is named `collect_options`.
It contains the lines that list the options for implementing the macro `snip:collect`.

The snippet `collect_options` is defined in the file {%#file (format=`$simpleName`) {%@snip:file collect_options%}%} at the line {%@snip:line collect_options%}.

You can find the previous sentence in the {%@file (format=`$simpleName`) README.adoc.jam%} file as:
{%sample/
{%@escape* ``The snippet `collect_options` is defined
in the file {%#file (format=`$simpleName`) {%@snip:file collect_options%}%}
at the line {%@snip:line collect_options%}.``%}
%}

You can use this macro to refer to a source code line or if you want to include some source code into your documentation with the actual positions as line numbering.
The syntax of the macro is

{%sample/
{@snip:line snippet_name}
%}

{%@define SNIPLINE_NOCOMMENT=The text following the snippet id is ignored, reserved for future development.%}
{%SNIPLINE_NOCOMMENT%}

[[snipFile]]
=== {%macroChapter%}`snip:file`

The macro `snip:file` returns the file's name where the snippet is defined.
The returned file name is a full absolute path.
If you want to display only the name or the directory, you can use the macro <<file,`file`>> to format the output.
It is recommended to use this macro together with the macro <<snipLine,`snip:line`>> described above.

You can use this macro to refer to a source file.
The syntax of the macro is

{%sample/
{@snip:file snippet_name}
%}

{%SNIPLINE_NOCOMMENT%}

[[snipTransform]]
=== {%macroChapter%}`snip:transform`
{%#snip:check file={%JAVA_DIR%}SnipTransform.java hash=cf639f9c%}

The `snip:transform` macro integrates the functionality of the macros

* `kill`
* `skipLines`
* `range` or `ranges`
* `replaceLines`
* `trimLines`
* `reflow`
* `numberLines`
* `untab`

It can kill/keep lines, skip, replace, trim, lines, select line ranges; it can reflow the lines, replace tabs with spaces, and it can number the lines.

{%parameterized%}

The macro implementation itself is calling the underlying other macros, so the functionality what and how it does the above actions are identical.
The purpose of the macro is to provide a shorthand for the common use case of the other macros used together.

The macro is configured with parameters in a similar way as the underlying macros.
The parameters are the same as in those macros, and they are used by the underlying macros the same way.
There are two differences, however.

1. The `snip:transform` macro does not use any user defined macro or option as a parameter.
You cannot, for example, `{@define replace=/foo/bar/}` and hope that `snip:transform` will replace `foo` with `bar`.
You have to use the parameter `replace` as a macro option.

2. There is an extra parameter named `action` (alias `actions`, plural) that lists the actions to perform.

The names for the actions are the followings:

* `kill`
* `skip`
* `range` or `ranges`
* `replace`
* `trim`
* `reflow`
* `number`
* `untab`

If you have a block that you want simultaneously trim and then number the lines, you have to write

{%sample/
{@snip:transform actions=trim,number
         wuff
        line
     Mayak
            Canoe
}
%}

which will result

{%output%}

This is essentially the same as

{%sample/
{#numberLines
{@trimLines
         wuff
        line
     Mayak
            Canoe
}}
%}

eventually with the same result:

{%output%}

The `snip:transform` takes all the actions in the order as they are specified and invokes the macros implementing them passing the parameters.
It is not possible to invoke one action more than once.
Any syntax allowing the separation of the parameters of one execution from another would be complex and probably hard to read.

Some actions have parameters that are the same as the name of the action.
These are `skip`, `range`, `kill`, `trim` and `replace`.
When one of these parameters is specified there may not be a need to specify the action separately.
It is evident that

{%sample/
{@snip:transform kill=A
Apple
Birnen
Birds
Sumatra
}
%}

will delete all lines that contain the uppercase letter `A` and will result:

{%output%}

On the other hand

{%sample/
{@snip:transform pattern=A
 ...
}
%}

does not work, even though the parameter `pattern` is the alias of `kill`.

The following parameters will add the action implicitly to the list:

* `kill` will add the action `kill`
* `keep` will add the action `kill`
* `skip` will add the action `skip`
* `lines`, `range` or `ranges` will add the action `range`
* `replace` will add the action `replace`
* `tab` or `tabSize` will add the action `untab`
* `trim` will add the action `trim`

If an action is already in the list (they are present in the parameter `actions`) they are not added again.
Also, their position remains as specified in the parameter `actions`.
When added, it is in the order as they are listed here in the documentation.
The actual order of the parameters in the macro is irrelevant.
When implicitly added `kill` will always precede `skip` and `replace`.
Likewise `skip` will precede `replace`.

A parameter other than these belonging to an action not listed in the `actions` parameter is an error.
You cannot, for example, specify `width` without adding `reflow` to the actions as it is not readable what the meaning of `width` is without `reflow`.

You will list the action in the `actions` parameter if you want to use it in a different place/order than the one it would get added implicitly.
For example, you want to kill a few lines and also number the lines.
If you do not list the action `kill` then it will be executed after the numbering.
When the lines are deleted, the numbering will have gaps.
It may be your intention, but usually it is not.

[NOTE]
====
The macro `snip:transform` is just a wrapper around the underlying macros.
It first looks up the macros by the name and then invokes them according to the parameters.
It is usually not interesting for the user of the macro.
The underlying macros are implemented in the snippet package, just like `snip:transform` itself.

Jamal, however, makes it possible to redefine built-in macros locally and globally via the `use` macro.
If any of the underlying macros are redefined when the `snip:transform` is invoked, then the actual macro will be invoked.
It also implies that the developers should implement these macros as compatible as the macro of the same name in the snippet package.
They have to implement the `BlockConverter` interface, and their `convertTextBlock()` method should accept the same parameters as their snippet counterpart.
====

The parameters for the `snip:transform` are:

* `action`, (alias `actions`) listing the actions to perform.
* `kill`, (alias `pattern`) passed to `killLines`
* `keep` passed to `killLines`
* `format` passed to `NumberLines`
* `start`  passed to `NumberLines`
* `step` passed to `NumberLines`
* `width` passed to `reflow`
* `replace` passed to `replaceLines`
* `detectNoChange` passed to `replaceLines`
* `skip` passed to `skipLines`
* `endSkip` passed to `skipLines`
* `margin` passed to `trimLines`
* `trimVertical` passed to `trimLines`
* `verticalTrimOnly` passed to `trimLines`
* `tab` or `tabSize` passed to `untab`. Note that the original `untab` parameter is not supported in the `snip:transform` macro.
The reason for that is readability. While `untab size` may be acceptable, it is not clear what the meaning of `size` is in `snip:transform`.
* `lines` (alias `range`, `ranges`) passed to `range`

The meaning and the interpretation of the parameters is the same as for the underlying macros and documented there.

[[lineCount]]
=== {%macroChapter%}`lineCount`
{%#snip:check file={%JAVA_DIR%}LineCount.java hash=6fe78fb5%}
This macro counts the lines in the content and returns the number of lines in decimal format.

{%sample/
{@lineCount
1
2
3}
%}

results

{%output%}

[[listDir]]
=== {%macroChapter%}`listDir`
{%#snip:check file={%JAVA_DIR%}ListDir.java hash=42019296%}
This macro lists the files in a directory and then returns the list of the formatted files.
The format of the macro is:

[source]
----
{@listDir (options) directory}
----

The parameter `directory` can be absolute or relative to the currently processed document.
The options are

* `format` specifying the format of the individual files

* `separator` to specify the separator. The default is `,` (comma).

* `grep` to specify a regular expression to filter the files based on their content.
Only the files that contain a string that matches the `grep` pattern will be listed.

* `pattern` to specify a regular expression to filter the files based on their name

* `maxDepth` is the maximum depth of recursion into subdirectories.
Specify `1` in case you do not want to recurse into subdirectories.

* `followSymlinks` to follow symbolic links

* `countOnly` (alias `count`) returns the number of the files as a string instead of the list of the file names.

The returned names of the files and directories are comma separated by default.
This makes the use of the macro a good candidate to provide the list elements for a `for` loop.
For example,

{%sample/
{#for macroJavaFile in ({@listDir (format=$simpleName) ./src/main/java/javax0/jamal/})=
- macroJavaFile}
%}

will result

{%output%}

The macro `for` is used with the `#` character, so the macro `listDir` is evaluated before executing the `for`.
The listing of the files is recursive and is unlimited by default.
The parameter `maxDepth` can limit the recursion.
The same listing limited to 1 depth (non-recursive) is the following

{%sample/
{#for macroJavaFile in ({#listDir (format=$simpleName) ./src/main/java/javax0/jamal/
{@define maxDepth=1}})=
- macroJavaFile}
%}

will result

{%output%}

The default formatting for the list of the files is the name of the file.
The parameter `format` can define other formats.
This format can contain placeholder, and these will be replaced with actual parameters of the files.
When used in a multivariable for loop, then the format usually has the format

[source]
----
$placeholdes1|placeholder2| ... |placeholder3
----

This is because the `|` character is the default separator for the different values in a `for` macro loop.

The possible placeholders are:

{%#snip:define listDirFormats$formatted=
{%#replaceLines
{%@define replace =`\n`
^\s*"(.*?)".*//\s*(.*)$
* `$1` will be replaced by the $2
OTF
of the file.
TITF
string literal `true` if the file
FO
`false` otherwise.
%}
{%#snip listDirFormats%}%}%}

{%@snip listDirFormats$formatted

* `$size` will be replaced by the size of the file.
* `$time` will be replaced by the modification time of the file.
* `$absolutePath` will be replaced by the absolute path of the file.
* `$name` will be replaced by the name of the file.
* `$simpleName` will be replaced by the simple name of the file.
* `$isDirectory` will be replaced by the string literal `true` if the file is a directory, `false` otherwise.
* `$isFile` will be replaced by the string literal `true` if the file is a plain file, `false` otherwise.
* `$isHidden` will be replaced by the string literal `true` if the file is hidden, `false` otherwise.
* `$canExecute` will be replaced by the string literal `true` if the file can be executed, `false` otherwise.
* `$canRead` will be replaced by the TIFT can be read, `false` otherwise.
* `$canWrite` will be replaced by the string literal `true` if the file can be written, `false` otherwise.
%}

For example,

{%sample/
{!#for (name,size) in ({#listDir ./src/main/java/javax0/jamal/
{@define format=$simpleName|$size}
})=
- name: {`@format /%,d/(int)size} bytes}
%}

will result
{%#snip:define listDir3=
{%output%}%}\

{%@snip listDir3
[source]
----
- jamal: 96 bytes
- snippet: 1,440 bytes
- Snip.java: 2,738 bytes
- SnipSave.java: 4,856 bytes
- Case.java: 2,273 bytes
- NumberLines.java: 2,756 bytes
- RangeMacro.java: 1,240 bytes
- Untab.java: 2,285 bytes
- DateMacro.java: 613 bytes
- Format.java: 930 bytes
- Update.java: 3,754 bytes
- SnipTransform.java: 16,201 bytes
- FilesMacro.java: 5,196 bytes
- Collect.java: 17,685 bytes
- SnipFile.java: 680 bytes
- TrimLines.java: 4,213 bytes
- ThinXml.java: 8,786 bytes
- LineCount.java: 604 bytes
- Replace.java: 1,775 bytes
- SnipLine.java: 691 bytes
- SnipXml.java: 1,489 bytes
- ThinXmlMacro.java: 585 bytes
- BlockConverter.java: 1,822 bytes
- Counter.java: 3,691 bytes
- StringMacros.java: 6,429 bytes
- Clear.java: 434 bytes
- KillLines.java: 1,659 bytes
- SnipLoad.java: 3,530 bytes
- Rot13.java: 907 bytes
- SnippetStore.java: 10,730 bytes
- ListDir.java: 5,583 bytes
- XmlFormat.java: 3,514 bytes
- SnippetXmlReader.java: 6,607 bytes
- XmlInsert.java: 6,177 bytes
- SnipProperties.java: 1,485 bytes
- Xml.java: 1,543 bytes
- CounterMacro.java: 1,811 bytes
- SnipList.java: 1,260 bytes
- XmlDocument.java: 5,656 bytes
- Java.java: 10,404 bytes
- ReplaceLines.java: 2,982 bytes
- SkipLines.java: 2,720 bytes
- SnipCheck.java: 5,866 bytes
- Reflow.java: 1,981 bytes
- Snippet.java: 1,088 bytes
----
%}

If the option `followSymlinks` is used, like in

[source]
----
{@options followSymlinks}
----

then the recursive collection process for collecting the files will follow symlinks.

The separator character between the formatted items is a comma by default.
The option `separator` or its alias `sep` can modify it.
For example the example:

{%sample/
{#listDir (format=$simpleName maxDepth=1 sep=*) ./src/main/java/javax0/jamal/}
%}

will result

{%output%}

[[xmlFormat]]
=== {%macroChapter%}`xmlFormat`
{%#snip:check file={%JAVA_DIR%}XmlFormat.java hash=aca81857%}
The macro `xmlFormat` interprets the input as an XML document if there is any, resulting in the formatted document.
If the input is empty or contains only spaces, it registers a post-processor that runs after the Jamal processing and formats the final output as XML.
For example,

{%sample/
{#xmlFormat
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion><name>jamal snippet</name><packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId><artifactId>jamal-snippet</artifactId><version>{%VERSION%}</version>
</project>
}
%}

will result

{%output%}

The default tabulation size is four.
You can alter it by defining the parameter `tabsize`.
For example,

{%sample/
{#xmlFormat
<?xml version="1.0" encoding="UTF-8" standalone="no"?>{@define tabsize=0}
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion><name>jamal snippet</name><packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId><artifactId>jamal-snippet</artifactId><version>{%VERSION%}</version>
</project>
}
%}

will result

{%output%}

As you can see, there is no tabulation in this case.

There is another use of the macro `xmlFormat`.
If you do not include any XML or anything else into the macro as input, the macro will treat this as a command to format the whole output.
It registers itself into the processor, and when the processing is finished, this registered call-back starts.
At that point, it will format the output of the processing.
That way, you can easily format a whole processed file.

The previous example that we used before can also be formulated this way.

{%sample/
{#xmlFormat}
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion><name>jamal snippet</name><packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId><artifactId>jamal-snippet</artifactId><version>{%VERSION%}</version>
</project>
%}

Note that the macro invocation `{#xmlFormat}` in this case can be anywhere in the input.
The formatting will take place postponed when the processing is finished.
It will result in the same output as before:

{%output%}

The macro can also convert thin XML to normal XML.
Thin XML is the same as normal XML, but the tags start without the `<` character, and the closing tag is omitted.
The actual place of the closing tag is determined by the position of the opening tag.
Whenever a tag line (containing a `>` character after a tag name) or a text line start on a column smaller than the tag tabulation the tag is closed.

To use the thin XML format the parameter `thin` must be specified.

For example:

{%sample/
{#xmlFormat (thin)
project>
  modelVersion>4.0.0
  name>jamal snippet
  packaging>jar
  groupId>com.javax0.jamal
  artifactId>jamal-snippet
  version>{%VERSION%}
  parent>
    groupId>com.javax0.jamal
    artifactId>jamal-parent
    version>1.10.3-SNAPSHOT
    relativePath>../jamal-parent
}
%}

will result

{%output%}

For more examples and detailed explanation of the thin XML format, see the link:./THINXML.adoc[Thin XML Format] page.

[[thinXml]]
=== {%macroChapter%}`thinXml`

This macro converts thin XML to normal XML.
Although the macro <<xmlFormat,`xmlFormat`>> can also do the conversion it works only for full XML files and not for XML fragments.
If the output is not a full XML then the macro `xmlFormat` may fail.
This macro does only the conversion and does not format the XML or check in any way that the output os correct.
It is useful when you want to convert a thin XML fraction to normal XML.

For example:

{%sample/
{#thinXml
  modelVersion>4.0.0
  name>jamal snippet
  packaging>jar
  groupId>com.javax0.jamal
  artifactId>jamal-snippet
  version>{%VERSION%}
  parent>
    groupId>com.javax0.jamal
    artifactId>jamal-parent
    version>1.10.3-SNAPSHOT
    relativePath>../jamal-parent
}
%}

will result

{%output%}

As you can see in this example the output is not a full XML file.
It is not formatted also and there is no leading ```<?xml version="1.0" encoding="UTF-8" standalone="no"?>``` line.

For more examples and detailed explanation of the thin XML format, see the link:./THINXML.adoc[Thin XML Format] page.

[[date]]
=== {%macroChapter%}`date`
{%#snip:check file={%JAVA_DIR%}DateMacro.java hash=e3b4a8a8.31ed301c%}
This macro will return the current date formatted using Java `SimpleDateFormat`.
The format string is the input of the macro.

Example

{%sample/
{@date yyyy-MM-dd HH:mm:ss}
%}

will result in the output

{%#snip:define dateOutput={%output%}%}\
{%@snip dateOutput%}

[[format]]
=== {%macroChapter%}`format`
{%#snip:check file={%JAVA_DIR%}Format.java hash=4bb6050d%}
You can use the macro `format` to format the arguments.
{%standardInput%}

The first argument will be interpreted as the format string.
The rest of the arguments will be used as the values for the formatting.
By the nature of Jamal, all these arguments are strings.
Since the parameters to the underlying `String::format` method are not only strings, they can be converted.
If any of the parameters starts with a `(xxx)` string, then the string will be converted to the type`xxx` before passing to `String::format` as an argument.
This format is similar to the cast syntax of Java and C.

The `xxx` can be

{%!@for type in (int,long,double,float,boolean,short,byte)=
* `type`, the conversion will call {%#case:cap {%@replace /type/int/integer%}%}::parse{%@case:cap type%}.%}
* `char`, the conversion will fetch the first character of the parameter.

Examples:

{%sample/
{@define LONG=5564444443455587466}
{@format /%,016d/(int)  587466}
{#format /%x/(long){LONG}}}
{@format /%,016.4f/(double)587466}
{@format /%e/(double)587466}
{@format /%e is %s/(double)587466/5.874660e+05}
{#format /hashCode(0x%x)=0x%h/(long){LONG}/(long){LONG}}
%}

will result in the output

{%#snip:define formatOutput={%output%}%}\
{%@snip formatOutput
[source]
----
000000000587,466
4d38e0bd5891048a}
0000587,466.0000
5.874660e+05
5.874660e+05 is 5.874660e+05
hashCode(0x4d38e0bd5891048a)=0x15a9e437
----
%}

[[numbers]]
=== {%macroChapter%}`numbers`

{%!@snip numbers%}

[[unicode]]
=== {%macroChapter%}`unicode`

{%!@snip unicode%}

[[case]]
=== {%macroChapter%}`case:lower`, `case:upper`, ...
{%#snip:check file={%JAVA_DIR%}Case.java hash=1dbb1c57%}
There are a few character case-changing macros implemented in the snippet package.
These are:

{%@define case(lower)=* `case:lower` changes the characters in the input to lower case letters%}
{%case lower%}
{%case upper%}
{%@define case(cap,upper)=* `case:cap` changes the first character in the input to upper case letter%}
{%case/cap/upper%}
{%case/decap/lower%}

[[file]]
=== {%macroChapter%}`file`
{%#snip:check file={%JAVA_DIR%}FilesMacro.java hash=26a27a4c%}
{%@define fileDirectory($what)=
You can use this macro to include the name of a $what in the documentation.
First, it seems counterintuitive to have a macro for that.
You can type in the name of the $what, and it will appear in the output.

The real added value of the macro is that it checks that the $what exists.
The macro will error if the $what does not exist or is not a $what.
It helps the maintenance of the documentation.
If the $what gets renamed, moved, or deleted, the document will not compile until you follow the change.

The macro can also format the name of the $what.
It uses the value of the user-defined macro `$whatFormat` for the purpose.
If this macro is defined outside the `$what` macro, then the $what names will be formatted using the same format.
For example, you can write%}\
{%fileDirectory file%}

{%sample/
When Jamal processes this file it will generate {@file (format=`$name`)README.adoc}.
%}

will result

{%#snip:define fileOutput={%output%}%}\
{%@snip fileOutput
[source]
----
When Jamal processes this file it will generate `README.adoc`.
----
%}

In the format you can use the following placeholders:
{%@comment the two replaces are executed from left to right. The first one puts a ! after the `xxx` name, and the second one finds it.%}

{%@snip (replace="|^.*?\"(.*?)\"|* `$1`! <- this is found and replaced by the second 'replace'|"
         replace="|!.*?//||")

         fileMacroFormatPlaceholders
%}

{%@define SUPPORT_ROOT($macro)=
The macro also supports the option `root`.
This can be used to define the root directory for the files' and directories' location.
The usual use is to define `root` as a global macro and all `$macro` macros should use file names relative to that following the definition.
This may save some time when you are referring to many files in a deep directory structure relative to the document file.%}{%SUPPORT_ROOT/file%}

[[directory]]
=== {%macroChapter%}`directory`
{%#snip:check file={%JAVA_DIR%}FilesMacro.java hash=26a27a4c%}
{%fileDirectory directory%}

{%sample/
This file is in the directory {@define directoryFormat=`$name`}{@directory ../jamal-snippet}.
%}

will result

{%#snip:define dirOutput={%output%}%}\
{%@snip dirOutput
[source]
----
This file is in the directory `../jamal-snippet`.
----
%}

In the format you can use the following placeholders:
{%#snip:define fileMacroFormatPlaceholdersFormatted=
{%@snip (replace="|^.*?\"(.*?)\"|* `$1`!|!.*?//||") fileMacroFormatPlaceholders %}%}

{%#replace |{%@snip fileMacroFormatPlaceholdersFormatted%}|file|directory%}

{%SUPPORT_ROOT/directory%}

[[Java]]
=== {%macroChapter%}Java Macros
{%#snip:check file={%JAVA_DIR%}Java.java hash=2fab387d%}

[[java:class]]
==== `java:class`

{%@define classMethodMacroIntro($x)=
The macro `java:$x` checks that the parameter is a valid Java $x and found on the classpath.
It is an error if the class is not on the classpath.
This macro is useful when you document Java source code and run the Jamal conversion from a unit test.
In this case, the macro will see the test and main classes.
It can check that the $x mentioned in the documentation is still there; it was not deleted or renamed.

When you run the conversion outside the code of the documented program, the $x is not on the classpath.
You can use the `java:sources` macro to include the source code as well as the compiled byte codes in the documentation to overcome this limitation.
It is typically the case when you use IntelliJ and Asciidoctor plugin.

Note that the Java compiler may not be available in the JRE executing the IntelliJ editor.
In this case, the macro will find the class if you also specify the compiled classes using the parameter `classes` to the macro `java:sources`.

%}\
{%classMethodMacroIntro class%}

The output of the macro is the class formatted.
The formatting is the simple name of the class by default.
The formatting can be defined by the parameter `classFormat`.
For example:

{%sample/
The class that implements the macro `java:class` is
{@java:class javax0.jamal.snippet.Java$ClassMacro}.
%}

will result in the output

{%#snip:define class1={%output%}%}\
{%@snip class1
[source]
----
The class that implements the macro `java:class` is
ClassMacro.
----
%}

The format string can be any string with `$` prefixed placeholders.
The placeholders that the macro handles are:

{%#replaceLines replace="/^\\s*\"\\$(.*)\"\\s*,?/* `\\$$1` will be replaced by the result of calling `$1()`"
{%@snip classFormats%}%}

For example

{%sample/
The class that implements the macro `java:class` is
{@define classFormat=$canonicalName}\
{@java:class javax0.jamal.snippet.Java$ClassMacro} with the canonical name, and
{@define classFormat=$name}\
{@java:class javax0.jamal.snippet.Java$ClassMacro} with the "normal" name.
It is in the package {#java:class javax0.jamal.snippet.Java$ClassMacro {@define classFormat=$packageName}}
{@java:class javax0.jamal.snippet.Java$ClassMacro} is still the "normal" name,
format defined inside the macro is local.
{@java:class (format="$simpleName") javax0.jamal.snippet.Java$ClassMacro} is the simple name.
%}

will result in the output

{%#snip:define class2={%output%}%}\
{%@snip class2
[source]
----
The class that implements the macro `java:class` is
javax0.jamal.snippet.Java.ClassMacro with the canonical name, and
javax0.jamal.snippet.Java$ClassMacro with the "normal" name.
It is in the package javax0.jamal.snippet
javax0.jamal.snippet.Java$ClassMacro is still the "normal" name,
format defined inside the macro is local.
----
%}

It is not recommended to overuse the format string.
Do not include verbatim text into the format string.
Choose a format string you want to refer to the classes and use it globally in the document.

[[java:field]]
==== `java:field`

{%classMethodMacroIntro field%}
In addition to that the value of the value of the field can also be used in the formatting in case the field is both `static` and `final`.
{%sample/
{@define field=javax0.jamal.api.SpecialCharacters#PRE_EVALUATE}
The field {#java:field (format="$name") {field}}
defined in the class {#java:field (format="$className") {field}}
is both `static` and `final` and has the value {#java:field (format="$value") {field}}
%}

will result in the output

{%output%}

The format string can be any string with `$` prefixed placeholders.
The placeholders that the macro handles are:
{%@define replace=`\n`
^.*?"(.*?)".*//\s*(.*)$
* `$1` will be replaced by the $2
OTFDC
of the fields' defining class
OTF
of the field
\).and\(
%}
{%#snip:define fieldFormatFormatted={%#replaceLines
{%@snip fieldFormats%}%}%}
{%@snip fieldFormatFormatted
* `$name` will be replaced by the name of the field
* `$classSimpleName` will be replaced by the simple name of the fields's defining class
* `$className` will be replaced by the name of the of the fields's defining class
* `$classCanonicalName` will be replaced by the canonical name of the fields's defining class
* `$classTypeName` will be replaced by the type name of the fields's defining class
* `$packageName` will be replaced by the package where the method is
* `$typeClass` will be replaced by the type of the field
* `$modifiers` will be replaced by the modifiers list of the method
* `$value` will be replaced by the value of the field in case the field is both `static` and `final`
%}

[[java:method]]
==== `java:method`

{%classMethodMacroIntro method%}

The output of the macro is the method formatted.
The formatting is the name of the method by default.
The formatting can be defined by the parameter `methodFormat`.
For example:

{%sample/
{@define method=/javax0.jamal.snippet.Java$MethodMacro/evaluate}\
{#java:method {method}}
%}

will result in the output

{%#snip:define method1={%output%}%}\
{%@snip method1
[source]
----
evaluate
----
%}

The macro can have two arguments, using the link:../README.adoc#argsplit[Standard Built-In Macro Argument Splitting] or one, specifying the full name of the method.
The method's full name is the class's full name, and the method name separated by either a `#` character or by `::` characters.

The format string can be any string with `$` prefixed placeholders.
The placeholders that the macro handles are:
{%@define replace=`\n`
^.*?"(.*?)".*//\s*(.*)$
* `$1` will be replaced by the $2
OTMDC
of the method's defining class
OTM
of the method
%}
{%#snip:define methodFormatFormatted={%#replaceLines
{%@snip methodFormats%}%}%}
{%@snip methodFormatFormatted
* `$classSimpleName` will be replaced by the simple name of the method's defining class
* `$className` will be replaced by the name of the of the method's defining class
* `$classCanonicalName` will be replaced by the canonical name of the method's defining class
* `$classTypeName` will be replaced by the type name of the method's defining class
* `$packageName` will be replaced by the package where the method is
* `$name` will be replaced by the name of the method
* `$typeClass` will be replaced by the return type of the method
* `$exceptions` will be replaced by the comma separated values of the exception types the method throws
* `$parameterTypes` will be replaced by the comma separated parameter types
* `$parameterCount` will be replaced by the number of the parameters in decimal format
* `$modifiers` will be replaced by the modifiers list of the method
%}

These formats can be used in your macros directly or using the macros defined in the jim file `res:snippet.jim`.
For example,

{%sample/
The class that implements the macro `java:method` is '{#java:method {method}{@define methodFormat=$name}}()',
but it is simpler to import the jim file included in the snippet library

            {@import res:snippet.jim}\

and use the user defined macros, like the following:

{java:method:modifiers |{method}}\
{java:method:classSimpleName |{method}}\
::{java:method:name |{method}}({java:method:parameterTypes:simpleName |{method}})
%}

will result in the output

{%#snip:define method2={%output%}%}\
{%@snip method2
[source]
----
The class that implements the macro `java:method` is 'evaluate()',
but it is simpler to import the jim file included in the snippet library


and use the user defined macros, like the following:

publicMethodMacro::evaluate(Input,Processor)
----
%}

[[java:sources]]
==== `java:sources`

This macro will read Java sources, compile them and make them available for the other macros.
Think of this macro as a location declaration of the Java files documented.
You can specify the location of the source code as well as the location of the compiled class files.
To do that, the macro has four parameters:

* `src` is the location of the source files. It is also aliased as `source` and `sources`.
* `class` is the location of the compiled class files. It is also aliased as `classes`.
* `store` can specify the name of the macro holding the loaded classes.
See details below.
* `options` aliased as `compilerOptions` can specify the options passed to the Java compiler.
You can use this parameter to pass options like `-cp` or `-classpath` to the compiler.

{%@define NOPAREN=
Since the macro does not use its input, the parameters can be specified in the macro call without enclosing them between parentheses.%}{%NOPAREN%}

The macro will first try to compile the source files.
It will try to load the classes from the class files if the compilation fails for any reason.

Jamal may be running with a JDK that can provide a Java compiler instance for Java.
This is the case when Jamal is executed from the command line, from a Maven extension, etc.
Executing Jamal inside IntelliJ as an Asciidoctor plugin preprocessor may not provide a Java compiler.
The compilation may also fail when there are external dependencies needed for the compilation.

If there is no source location defined or there is no compiler available, then the macro will load the already compiled classes.
In other cases, the macro will read the source files, compile them and load the classes for the macros to use.

NOTE: Compiling the source code may need significant resource.
You may consider omitting the `src` parameter if you use the macros only for class, method and field names formatting.
On the other hand, when you use the macros for code generation, you may stick to the source code.
(See also the <<java:insert,`java:insert`>> macro.)
In those situations, the compiled code, before the code generation, may be out of date or even unavailable when Jamal is executed as part of the compilation.

When the classes are loaded form the compiled class files, it may happen that not all classes are loaded.
For example, if a class extends a library class or interface, not provided as source code, then class loading will fail for that class.
The other classes will, however, still be loaded, and the macros will be able to use them.

This macro has a third option named `store`.
When the classes are loaded they are stored in a user defined macro named `{%@snip LOADED_CLASSES%}`.
You can load different sets of class files providing a different name in this parameter.
This parameter can also be used in the macros

* <<java:classes,`java:classes`>>
* <<java:methods,`java:methods`>>
* <<java:fields,`java:fields`>>

but not in

* <<java:class,`java:class`>>
* <<java:method,`java:method`>>
* <<java:field,`java:field`>>

The plural versions are used for code generation.
The singular versions are used for formatting and will always use the classes in the executing JVM or those loaded to the default macro class store.

[[java:classes]]
==== `java:classes`

This macro will return the list of selected classes.
The classes have to be loaded first using the <<java:sources,`java:sources`>> macro.
The macro has three parameters:

{%@define STORE=* `store` can specify an alternative user defined macro where the classes are stored.
Use this option specifying the same name as in the macro <<java:sources,`java:sources`>>.
It is recommended not to use this option.
%}{%STORE%}
{%@define SELECTOR($x)=* `selector`, aliased as `only`, and `filter` should be used to filter the $x.
The value of this parameter is a selector expression.
This selector expression is interpreted by the tool REFI as documented `https://github.com/verhas/refi`.
%}{%SELECTOR/classes%}
{%@define SEP($x)=* `sep`, aliased as `separator` canbe used to specify the separator string between the $x.
The default value is comma, which makes the result usable in a `for` macro.
Do not forget to use the `[evalist]` option when using in the `for` macro the result of this macro.
%}{%SEP/classes%}
{%NOPAREN%}

The returned list will contain the names of the classes.

[[java:methods]]
==== `java:methods`

This macro will return a list of selected methods.
The macro has four parameters:

{%STORE%}
{%SELECTOR(methods)%}
{%@define CLASS($x)=* `class` can be used to specify a selector for the classes where the $x are to be selected from.
%}{%CLASS/methods%}
{%SEP(methods)%}

{%NOPAREN%}

The methods will be stored in user-defined macros.
The returned string is the name of the macro where the methods are stored.
These macros can be evaluated.
The macro will interpret the first argument as a formatting command and will return

* `class` will result the name of the class the method is declared in

* `name` will result the name of the class.
This is also the case when there is no parameter defined.

* `modifiers` will return the modifiers of the method.

* `modifiers-abstract` will return the modifiers of the method, minus the `abstract` modifier if there was such.

* `exceptions` will return the list of the exceptions the method throws.

* `args` will return the list of the arguments of the method.

* `call` will return the method call with the arguments.

* `callWith` will return the method call with the arguments provided in the macro.

* `type` the return type of the method.

* `signature` the signature of the method.
This formatting also interprets the following parameters as:

** `concrete` will return the signature of the method without the `abstract` modifier if there was such.
** `abstract` will return the signature of the method with the `abstract` modifier if there was such.
** `interface` will return the signature of the method without the `public` modifier, so it can be used in an interface.
** `public` will return the signature of the method with the `public` modifier, even if the original method was not public


[[java:fields]]
==== `java:fields`
This macro will return a list of selected fields.
The macro has four parameters:

{%STORE%}
{%SELECTOR(fields)%}
{%@define CLASS($x)=* `class` can be used to specify a selector for the classes where the $x are to be selected from.
%}{%CLASS/fields%}
{%SEP(fields)%}

{%NOPAREN%}

The fields will be stored in user-defined macros.
The returned string is the name of the macro where the fields are stored.
These macros can be evaluated.
The macro will interpret the first argument as a formatting command and will return

* `class` the class name the field is declared in.

* `name` the name of the field.
This is also the case when there is no parameter defined.

* `modifiers` the modifiers of the field.

* `modifiers-abstract` the modifiers of the field, minus the `abstract` modifier if there was such.

* `type` the type of the field.


[[java:insert]]
==== `java:insert`
{%#snip:check file={%JAVA_DIR%}JavaSourceInsert.java hash=4d8fb2a1%}

The macro `java:insert` can be used to insert the content of the macro into a Java source file into a segment.
The macro has three parameters:

* `file` is the name of the file where the segment is to be inserted.
  It is also aliased as `to` and `into`.

* `segment` is the name of the segment where the content is to be inserted.
  It is also aliased as `id` and `at`.
  This parameter is optional and is not needed if there is only one segment in the file.

* `check`, `checkUpdate`, `update`, `updateOnly` will do an extra step before updating the file.
It will do a lexical analysis on the original file and on the new version and compare the two.
If they are the same on the Java lexical level ignoring differences in comments and white-space, then the file is not updated.

+
This is useful not to ruin the already generated code when it was formatted and does not change other than that.
It can also be used when the build process runs in properly configured a CI/CD environment where the build process cannot write the source files.
In that case, the developer builds should update the source code, and the CI/CD process can see the already updated code.

+
The downside is that the comparison needs time and some memory.

* `failOnUpdate`, `failUpdate`, `updateError` will result an error if the file is updated.
Note that the processing will not stop, only the macro will result in an error at the end of the Jamal file processing.
If there are multiple `java:insert` macros in the file, then all of them will be processed the error will only happen at the end of the processing.
This option may be useful in a build process when the code generation runs after the compilation.
If the code was updated, then the compilation should fail.
The code, however, was already updated and the compilation started again will be successful.


The parameters are not enclosed between any characters.
They follow the macro name directly until the end of the line.

{%sample/
{@java:insert update to="Sample.java" id="segment"}
%}

The segment in the source file starts with a line

  //<editor-fold id="segment"...>

and it ends with

    //</editor-fold>

If there are lines between these two lines, they are deleted and replaced by the input of the macro.

If the macro input is empty, then the file writing is deferred until the end of the processing.
In this case, the content of the whole output is going to be used.

[NOTE]
====
When the macro writes its' input into the file, you will most probably want to use `#` as macro character.
That way, the input will be first processed.

The suggested practice is to name the file `XYZ.java.jam` for code to be inserted into `XYZ.java`.
Do not forget to add ``{%@escape*`.`{%@comment nosave%}`.`%}`` to the beginning of the file.
This will prevent the Asciidoctor version of Jamal overwriting the Java file when editing the macros.
====

[[String]]
=== {%macroChapter%}String Macros
{%#snip:check file={%JAVA_DIR%}StringMacros.java hash=6f0f6f85%}

[[string:contains]]
==== `string:contains`

This macro returns the string `true` if the input contains a text given as a parameter and the text `false` otherwise.
The macro handles two parameters:

* `text` {%alias string%} must be present, and it should specify the string to find in the input.

* `regex` is an optional parameter.
If it is `true`, then the text will be interpreted as a regular expression.
The macro will check if a match is found inside the input.
(It calls the Java regular expression matcher `find()`.)

[[string:quote]]
==== `string:quote`

This macro returns the input of the macro quoted.
You can use the string inside another string that way.
This macro is useful when the output is used as some programming language source.
Example:

{%sample/
{@string:quote This "is" quoted '
 new line is also quoted, tabs are also and line-feed also \ becomes doubled}
%}

will result

{%output%}

The actual conversions performed are:

* `\` -> `\\`
* tab -> `\t`
* back space -> `\b`
* new line -> `\n`
* line feed -> `\r`
* form feed -> `\f`
* `"` -> `\"`

[[string:equals]]
==== `string:equals`

This macro returns the string literal `true` or `false` comparing the two arguments.
It returns `true` if the two arguments are equal and `false` otherwise.
If the option `ignoreCase` is used, then the comparison is made ignoring the character casing.

Example:

{%sample/
{@string:equals/aaa/aaa}
{@string:equals/aaa/bbb}
%}

will result

{%output%}


[[string:startsWith]]
==== `string:startsWith`

This macro returns the string literal `true` or `false` comparing the two arguments.
It returns `true` if the first argument starts with the second argument and `false` otherwise.

Example:

{%sample/
{@string:startsWith/aaa/aa}
{@string:startsWith/aaa/ba}
%}

will result

{%output%}

[[string:endsWith]]
==== `string:endsWith`

This macro returns the string literal `true` or `false` comparing the two arguments.
It returns `true` if the first argument ends with the second argument and `false` otherwise.

Example:

{%sample/
{@string:endsWith/aaa/aa}
{@string:endsWith/aaa/ab}
%}

will result

{%output%}

[[string:reverse]]
==== `string:reverse`

This macro returns the reverse of the input string.
For example:

{%sample/
{@string:reverse 0123456789abcdefgh}
%}

will result

{%output%}

[[string:substring]]
==== `string:substring`

This macro returns a substring of the input.
The parameters are

* `begin` specifying the beginning of the substring (default is the start of the string), and

* `end` specifying the end of the substring (default is the end of the string).

If any of the parameters is a negative number, then the macro calculates the position from the end of the string.

Examples:

{%sample/
{@string:substring the whole string}
{@string:substring (begin=0 end=3)the first three character} only the'
{@string:substring (begin=1 end=-1)ythea}
%}

will result

{%output%}

[[string:length]]
==== `string:length`

This macro returns the length of the input.
The parameters are:

* `trim` tells the macro that the input has to be trimmed before calculating the length

* `left` tells the macro that the trimming has to be applied to the start (left) of the input

* `right` tells the macro that the trimming has to be applied to the end (right) of the input

You can use `left` and `right` together with `trim`.
It will have the same effect as using `trim` alone.
Using either `left` or `right` without trim is an error.

[[string:chop]]
==== `string:chop`

Chop off a substring from the start or from the end of the input.
The parameters are:

* `prefix`, `pre` or `start` can specify a string that the input may start with. If the input starts with this string, it will be removed.
* `postfix`, `post` or `end` can specify a string that the input may end with. If the input ends with this string, it will be removed.

* `ignorecase` or `ignoreCase` tells the macro that the strings are case-insensitive.

[[shell:var]]
=== {%macroChapter%}`shell:var`

This macro is a convenience tool replacing `$variable` and `pass:[${variable}]` sequences with the values of the variables.
The values of the variables can be provided and looked up from

* macro parameters in the string of the value of the parameter `variables`,
* macros defined,
* Java system variables,
* environment variables,

in this order.

{%sample/
{@define A=value}
{@shell:var $A}

%}

results in

{%output%}

The variable replacement is performed recursively.
If there is a variable reference in the result, then it will be replaced again.
Also, when the reference is `pass:[${string}]` formatted the `string` is first processed for variables.
This processing is done 100 levels deep.
If the macro detects a loop, then it will stop the processing and results in a `BadSyntax` exception.

Although `$` is a valid character in a macro name, you cannot reference a macro that has a $ in its name.
Also, the macro must not require any parameter.

[[hashCode]]
=== {%macroChapter%}`hashCode`
{%#snip:check file={%JAVA_DIR%}HashCode.java hash=7742f9d6%}

This macro returns the hash code of the macro input as a 64-character hexadecimal string.

{%sample/
{@hashCode abraka dabra}
%}

will result in

{%output%}

[[memoize]]
=== {%macroChapter%}`memoize`

{%!@snip Memoize%}


[[download]]
=== {%macroChapter%}`download`

{%!@snip Download%}

[[snip_update]]
=== {%macroChapter%}`snip:update`
{%#snip:check file={%JAVA_DIR%}Update.java hash=917df28d%}
This macro was used to automatically copy the content of the snippets into the `snip` macros.
Since the introduction of the WYSIWYG editing in IntelliJ, this feature is outdated.
Currently, the macro exists only for backward compatibility and does nothing.

Later releases will remove this macro.
When this happens, you can keep backward compatibility with

  {@use global comment as snip:update}

This will render the current, no operation functionality of the macro.

[[kroki]]
=== {%macroChapter%}Kroki

In this section, we will describe how to use the snippet handling macros together with the Kroki service.

The Kroki service is a free online service that can render diagrams from a text.
You can use the public service, or you can install the application in premise.
In this section, we will use the public service, but using an in premise installation is very similar.

The documentation of the service and the supported diagram types are available at https://kroki.io/.

There is direct support to include Kroki generated pictures for AsciiDoc and into Markdown documents.
There is a resource file in this module named `kroki.jim`.
You can import this file into your document using `{@import res:kroki.jim}` and use the macro defined in it.

The macro `kroki` has four parameters:

* The name of the diagram.
This will be used to name the generated picture file.

* The diagram type.
This can be any supported by the used Kroki service.

* The file type, which can be `png`, svg`, `jpeg` etc.
This parameter will be passed to the Kroki service as well as used as a file name extension.
The different possible file types are documented at https://kroki.io/.

* The diagram text.

The macro will encode the diagram text, send it to the Kroki service, download the generated picture and include it in the document.
The macro will use Markdown syntax for the picture of the including file name ends with `md.jam` and AsciiDoc syntax otherwise.

If you want some other syntax, you can use the macro `kroki:download`.
This macro has the same arguments and will return the downloaded picture's file name.

These macros will generate picture files with the given name and file type as an extension.
In addition to that, the macros will also generate a file with the same name and an extra extension `.hash`.
When the macro executes, it will invoke the web-based service only if the picture file does not exist, or if the diagram text has changed since the last execution.
You may want to add these files to your source repository to avoid unnecessary network traffic on the CI/CD server.