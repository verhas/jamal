== Jamal Snippet Handling Macros
{%@import res:jamal.jim%}\
{%@snip:collect from="src/main/java/"%}\
{%#define lastUpdated={%@date yyyy-MM-dd HH:mm:ss%}%}\
{%#snip:define lastUpdated={%lastUpdated%}%}\

{%@define standardInput= The macro scans the input using the <<../README.adoc#argsplit,Standard Built-In Macro Argument Splitting>>.%}

Snippet handling macros help you to include information from program source code into the documentation automatically.

When you document an application, there is a lot of information that changes by changing the source code.
These changes have to be followed in the documentation.
Some changes need manual editing.
Some changes can be automated.
When the functionality of the program changes, then the new documentation has to describe the new functionality.
We can hardly automate this change of documentation.
When some literal parameter also used in the document changes, then Jamal can automatically update the documentation.
A typical example is the version number of the application.
The documentation many times may refer to the latest version.

For example, if you want to use the latest version of Jamal Snippet macro as a dependency in a `pom.xml` file then you have to have the lines:

{%@snip:xml pom=pom.xml%}\
{%#define VERSION={%pom /project/version/text()%}%}\
[source,xml]
----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{%VERSION%}</version>
</dependency>
----

You see in the `README.adoc` file the actual version number converted from the `README.adoc.jam`.
The original file, however, contains

[source,xml]
----
{{%@ident%}%@snip:xml pom=pom.xml%{%@ident%}}\
{{%@ident%}%#define VERSION={{%@ident%}%pom /project/version/text()%{%@ident%}}%{%@ident%}}\
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{{%@ident%}%VERSION%{%@ident%}}</version>
</dependency>
----

The Jamal Snippet macros help you automate to insert actual values and code fragments from

* any source code
* XML file
* properties files.

These small text pieces are called snippets.

When the `.jam` file gets processed, the snippets will automatically contain the source code's actual text.
This way, it is easier to keep your documentation up to date.

=== Table of contents

. <<usage,Usage>>
. <<macros,Macros>>
[lowerroman, start=1]
.. <<snip_collect,`snip:collect`>>
.. <<snip_properties,`snip:properties`>>
.. <<snip_xml,`snip:xml`>>
.. <<xml_define,`xml:define`>>
.. <<xml_insert,`xml:insert`>>
.. <<snip_define,`snip:define`>>
.. <<snip_clear,`snip:clear`>>
.. <<snip,`snip`>>
.. <<snip_check,`snip:check`>>
.. <<snipList,`snip_list`>>
.. <<trimLines,`trimLines`>>
.. <<numberLines,`numberLines`>>
.. <<killLines,`killLines`>>
.. <<skipLines,`skipLines`>>
.. <<replace,`replace`>>
.. <<replaceLines,`replaceLines`>>
.. <<counter_define,`counter:define`>>
.. <<reflow,`reflow`>>
.. <<lineCount,`lineCount`>>
.. <<listDir,`listDir`>>
.. <<xmlFormat,`xmlFormat`>>
.. <<date,`date`>>
.. <<format,`format`>>
.. <<case,`case:lower`, `case:upper`, ...>>
.. <<file,`file`>>
.. <<directory,`directory`>>
.. <<Java,Java Macros>>
.. <<String,String Macros>>
.. <<snip_update,`snip:update`>>

{%@counter:define id=chapter format=%d. %}
{%@counter:define id=macroChapter format=$roman. %}

[[usage]]
=== {%chapter%}Usage

If you are using Jamal programmatically or from Maven then the dependency you have to add to your project is:

----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{%VERSION%}</version>
</dependency>
----

The macro classes are listed in the `provides` directive in the `module-info.java`; therefore, they are available for the Jama source code.
There is no need to invoke the `use` command to get access to these macros.

[[macros]]
=== {%chapter%}Macros
{%@define parameterized=
The first line following the macro identifier until the end of the line may contain parameters.
These parameters are parsed using the Standard Parameter Parsing as defined in <<{%@file ../PARAMS.adoc%},PARAMS>>.
%}
[[snip_collect]]
==== {%macroChapter%}`snip:collect`
Since 1.7.4 option `onceAs`

This macro collects text snippets from files.
The syntax of the macro is

[source]
----
{@snip:collect from="fileName" ...options}
----

`fileName` can be the name of a text file, or it can be a directory.
If the `fileName` is a text file, then the macro will collect the single file's snippets.
If the `fileName` is a directory, then the macro will collect the snippets from the files in that directory and from directories beneath recursively.

A snippet in a file is a series of lines that happen between

[source]
----
snippet name
----

and

[source]
----
end snippet
----

lines.

A special snippet containing only a single line can be specified preceeding it with a line

[source]
----
snipline name
----

In this case there is no need for `end snippet` line.
This way

[source]
----
// snippet MY_CONSTANT_SNIPPET_NAME
  public static final MY_CONSTANT = "Hello World";
// end snippet
----

is the same as

[source]
----
// snipline MY_CONSTANT_SNIPPET_NAME
  public static final MY_CONSTANT = "Hello World";
----

[NOTE]
====
The only difference is that the first version will contain a line with a trailing `\n` at the end of the line.
The `snipline` version does not contain the trailing `\n`.
====

There can be extra characters before or after the `snippet name` and/or the `end snippet` strings.
The only requirement is that the regular expression `snippet\s+([a-zA-Z0-9_$]+)` can be found in the starting line and `end\s+snippet` in the ending line.

[NOTE]
====
The definition and matching criteria of the start and the end of the snippet are very liberal.
The reason for that is to ease in recognizing these in different files.
The regular expressions will find snippet start and snippet ends in Java files, in XML, in Perl or Python code.
Essentially you should not have a problem signaling the start, and the end of the snippet in any program code that allows you to write some form of a comment.

The disadvantage of this liberal definition is that sometimes it finds lines that accidentally contain the word snippet.
If you look at the source code in the file {%@file src/main/java/javax0/jamal/snippet/TrimLines.java%} you can see examples.
The comment mentions snippets, and there is a word eligible to be an identifier after `snippet`, and the parsing thinks that this is a snippet start.
Eventually, there is no `end snippet` on the lines following it, which is an error the snippet collection process recognizes.
(Up to 1.7.2. Later versions use this file as a snippet source; thus, it has 'end snippet'.)
Still, you do not receive an error message.

That is because the collection process only recognizes this error but does not throw an exception.
The exception is thrown only when you want to use the `snip` macro for an unterminated snippet.

The possible situation may even be more complicated because the accidental word following `snippet` in a comment may also be used in other files as a snippet identifier.
The collector, sooner or later, will find that definition, and it will assume that the one with the error was just an accidental comment and replaces the old with the correct, error-free snippet.
It is still okay when the snippet collection finds these two snippets in the opposite order.
If there is already a correct, error-free snippet collected and the collection finds an erroneous one of the same name, it ignores that.

This way, the collection and the use of the snippets ignores the accidental snippet definitions, but at the same time, it can detect the mal-formed snippets.

If you look at the {%@file src/main/java/javax0/jamal/snippet/TrimLines.java%} in version 1.7.3 or later, you can see that there is a `// snippet` line in the code.
Because there is also an accidental `snippet` line before it, the collection would not find this line.
Because of the previous `snippet` line, the real `// snippet` line becomes part of the previous snippet.
The `// snippet` line is preceded by an `// end snippet` line to avoid this.
Such a line out of a snippet is ignored, and in this case, it closes the accidental snippet.
====

As you can see, the regular expression contains a collection group, which Jamal uses as the name of the snippet.
For example, the code

{%@snip:collect onceAs="sample.Java" from="src/test/java/javax0/jamal/documentation/Sample.java"%}
{%@snip:collect onceAs="sample.Java" from="src/test/java/javax0/jamal/documentation/Sample.java"%}

[source]
----
// snippet sample
{%@snip sample%}\
// snippet end
----

defines a snippet that is named `sample`.
The snippets can be used later using the <<snip,`snip`>> macro.

The output of the `collect` macro is an empty string.

The macro behaviour can be altered using options.
These options are parsed using the Standard Parameter Parsing as defined in <<{%@file ../PARAMS.adoc%},PARAMS>>.

{%#eval {%`@comment%}
{%#replaceLines replace="~.*?final\\s+var\\s+\\w+\\s*=\\s*Params\\..*holder\\(.*?\"(.*?)\".*~* `$1`~.*//~"
{%@snip collect_options%}
%}%}

If the parameter `start` or `liner` are defined, the value will be used as a snippet start matching regular expression.
They must have one collection group.

NOTE: We introduced this option to the `snip:collect` macro along with the Jamal doclet implementation.
When the individual documentation parts are processed in the same processor, the processing order is not guaranteed.
To refer to some snippets, you have to collect them.
To do that, you have to have the `snip:collect` in every JavaDoc, presumably using an imported file.
That collect macro should name the collection to avoid redefinition error.

[[snip_properties]]
==== {%macroChapter%}`snip:properties`

This macro will load properties from a "properties" file or an "XML" file.
The names of the properties will become the names of the snippets and the values of the snippets.

For example, the sample

{%sample/
{@snip:properties src/test/resources/javax0/jamal/snippet/testproperties.properties}
%}

{%#comment this output is evaluated because this is when the macro in the sample is evaluated
{%output%} but there is no output. The later examples use the snippets that this macro evaluation
was reading from the properties file.
%}\

will load the content of the file `javax0/jamal/snippet/testproperties.properties`, which is

[source]
----
{%@include ./src/test/resources/javax0/jamal/snippet/testproperties.properties%}
----

and thus using the `snip` macro, like

{%sample/
{@snip a}
%}

will result

{%#snip:define snipa={%output%}%}

{%@snip snipa
[source]
----
letter a
----
%}

If the file extension is `.xml`, the properties will be loaded as XML format properties.
For example, the same properties file in XML format looks like the following:

[source,xml]
----
{%@include ./src/test/resources/javax0/jamal/snippet/testproperties.xml%}
----

[[xml_define]]
==== {%macroChapter%}`xml:define`

This macro scans its input as an XML and assigns the parsed data to a "user-defined" macro.
The syntax of the command is:

[source]
----
{@xml:define macroName=xmlcontent}
----
{%@define XML_MACRO_USE=
The defined `macroName` macro can be used as an ordinary user-defined macro that accepts one, optional argument.
This user-defined macro evaluates in a particular way.
It uses the argument as an XPath expression and returns the value from the XML document that matches the argument.
If the XPath expression is missing then the whole XML content is converted to text formatted.
%}
{%XML_MACRO_USE%}

For example the `pom.xml` can be read using the following macro use:

{%sample/
{#xml:define pom={@include [verbatim]pom.xml}}\
{#define VERSION={pom /project/version/text()}}\
...
<version>{VERSION}</version>
...
%}

The result is:

{%output%}

[[snip_xml]]
==== {%macroChapter%}`snip:xml`

This macro loads an XML file and assigns it to a "user-defined" macro.
The syntax of the command is

[source]
----
{@snip:xml macroName=xml_file.xml}
----

{%XML_MACRO_USE%}

For example this document contains the following macros at the start:

{%sample/
{@snip:xml pom=pom.xml}\
{#define VERSION={pom /project/version/text()}}\
...
<version>{VERSION}</version>
...
%}

The result is:

{%output%}

which is the current version of the project as read from the `pom.xml` file.

[[xml_insert]]
==== {%macroChapter%}`xml:insert`

This macro can modify an XML formatted user defined macro inserting content into the XML document.
It can also be used to insert an XML fragment into the XML document, which is the output of the whole processing.
This latter use is for the case when the Jamal file processed creates an XML file.
The syntax of the command is

{%sample/
{@xml:insert (options) xml content}
%}

The options define the name of the xml formatted user defined macro the content should be inserted into as well as the xPath that defines the location of the insertion.

* `xpath` (alias `path`) defines the location in the original XML where to insert the content.

* `id`, (alias `to`) defines the name of the XML user defined macro which will be modified.
If this option is missing then the insertion will happen when the whole document processing is already finished.
In that case the target XML is the one, which is the result of the Jamal processing.
This is usable when the Jamal processing creates an XML as a result.
The insertions are done in the order of the `xml:insert` commands and after that the output will be the resulting XML formatted.

* `ifneeded` (alias `optional`) defines whether the insertion is optional.
If the location specified by the `path` already contains a tag with the given name, then the XML will not be modified.
Without this option a new child is appended having the name that may already be there.

* `tabsize` can specify the formatting tab size.
This makes only sense if the insertion happens to the final XML content of the processing.

The following example shows how to insert a new child into the XML document.

{%sample/
{@xml:define myXml=<xml>
<yml>babu</yml>
</xml>}\
{@xml:insert (to=myXml path=/xml) <zml>wuku</zml>}
{myXml}
%}

will result

{%output%}

The XML content is defined using the macro `xml:define`.
Later the content of this XML is modified using the macro `xml:insert`.
The content of the macro is converted to text and gets into the output when the name of the macro is used without the Xpath argument.

The following example demonstrates how the result of the processing can be modified.

{%sample/
<project>
{@xml:insert (path=/project ifneeded)<dependencies></dependencies>}
{@xml:insert (path=/project ifneeded)<plugins></plugins>}
{@xml:insert (path=/project ifneeded tabsize=2)<pluginManagement></pluginManagement>}
{@xml:insert (path=/project ifneeded)<dependencyManagement></dependencyManagement>}

{@xml:insert (path=/project/dependencies)
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{%VERSION%}</version>
</dependency>}
<plugins><plugin>
<artifactId>my-imaginary</artifactId>
<groupId>plugin</groupId>
<version>r65.1204-2021</version>
</plugin>
</plugins>

</project>
%}

will result


{%output%}

The insert macros in this example do not specify any `id`.
This means that all the modification is done to the XML, which is the whole document.
Also the modification happens at the end of the processing.

The first four insertions are optional in the sense that they will modify the output if there is no such tag in the XML.
They make not much sense in a simple XML file, like this, but in a larger XML, where the different parts come from different includes it may make sense.
Such insertions ensure that these parts are inserted if they are needed by other insertions.
The first four lines could be in a separate file and included using the `include` macro to support pom structure.

In the example the fifth insertion can only be executed successfully because the first one is there.
Without this there would be no `/project/dependencies` location in the XML file.
At the same time the second optional insertion for the `plugins` is ignored, because there is an explicit `plugins` tag in the content.
The fifth insertion adds a dependency to the `dependencies` tag.

[[snip_define]]
==== {%macroChapter%}`snip:define`

You can use this macro to define a snippet.
Snippets are usually collected from project files, but it is also possible to define them via the macro `snip:define`.
For example,

{%sample/
{@snip:define mySnippet=
It is the snippet, which is defined inside the file and not collected from an external file.
}
{@snip mySnippet
is used here, and then the rest of the text is ignored}
%}

will result

{%#snip:define mySnippet={%output%}%}

{%@snip mySnippet
[source]
----
It is the snippet, which is defined inside the file and not collected from an external file.
----
%}

[[snip_clear]]
==== {%macroChapter%}`snip:clear`

Calling this macro deletes all collected snippets from memory.
The result of the macro is an empty string.

[[snip]]
==== {%macroChapter%}`snip`

The `snip` macro should have one argument: the name of the snippet previously collected.
The result of the macro is the content of the snippet.

For example

[source]
----
{@snip snipped_id comment}
----

is replaced by the content of the snippet named `snipped_id`.
The macro reads the ID from the input, and it purposefully ignores the rest of the input.
The reason to have the rest of the input as the comment is to allow the Jamal file users to insert a description of the snippet.
You can manually copy the content of the snippet there, which helps the navigation in the source code, but at the same time, it is not a problem if the copy gets outdated.
The output fetched the content from the actual value of the snippet.

Starting with Jamal version 1.7.2, the `snippet_id` can also be followed by a regular expression.
You can use the regular expression to extract and use a smaller part from the first line of the snippet.
The typical use is when there is a constant defined in the code, and you want to reference the value of the constant.
In this case, you can add

[source,java]
----
// snippet snippet_id
...
// end snippet
----

lines before and after the line defining the constant, and add a regular expression with one capturing group.
For example, you can have

[source,java]
----
// snippet defaultShellName
public static final String DEFAULT_RUBY_SHELL_NAME = ":rubyShell";
// end snippet
----

and the Jamal code

[source,text]
----
{#define defaultShellName={@snip defaultShellName /"(.*)"/}}\
----

to gauge out the string `:rubyShell` from the source code.

If the first character after the `snippet_id` is a `/` character, the macro will treat the rest of the input as a regular expression.
This part also has to end using a `/`.
The characters between the first and the last `/` are interpreted as a regular expression.
This regex has to have at least one capturing group.
The macro will return the string captured by the first group.
The characters that follow the last `/` character are ignored, and eventually can not contain more `/` characters.

If the regular expression is not found in the first line of the snippet, or there is no capturing group, then the first line itself will result from the macro.

[[snip_check]]
==== {%macroChapter%}`snip:check`
{%@comment

This code below is a simple demonstration of a snip check that checks both the snippet and the whole file.
This check does not get into the processed output, but if you read this, you see a real-life example of snip:check.

%}\
{%@snip:check hash=4039b33b.289A44B3
              file=src/main/java/javax0/jamal/snippet/SnipCheck.java
              message="Review the whole chapter of 'snip:check'"
%}\

You can use this macro to enforce consistency between the documented system and the documentation.
Using this macro will nudge the maintainer to check the relevant parts of the document when the documented code changes.
The macro itself will not update the documentation.
It will warn with an error if some part of the documentation needs update due to changed application code.
That way, the document may remain up-to-date, and you will not forget to update it.

To use the macro, you should first select some part of the code.
This part can be one or more snippets and whole source files.
You specify file names using the `file` or `files` option of the macro.
Snippets are specified using the `id` or `ids` option.
You can define one or more files and snippets at the same time.
The values are comma-separated.

[source,text]
----
{@snip:check hash=2a4ddeab580ad1fe8c95a id=snippet1,snippet2
    file=src/main/java/javax0/jamal/snippet/SnipCheck.java,src/test/java/javax0/jamal/snippet/TestSnipCheck.java%}
----

The macro `snip:check` calculates a hashcode of the snippet.
The hashcode can also be specified in the macro option `hash` or `hashCode`.

(These hex code above is made up, `TestSnipChek.java` does not even exist.)

If this hash code is the same as the one calculated, the programmer did not change the code in the snippet.
If the codes are different, then the macro will error.
It means that the snippet or file has changed, and the documentation has to follow the change.
When the documentation is updated, you should also update the hash code.

Nothing will stop you from updating the hash code without updating the documentation, though.
It takes discipline to keep the documentation up-to-date.
This macro only helps not to forget some parts.

The hash code calculated contains 64 hexadecimal characters.
You may notice that the examples above contain less.
The macro accepts if only a few characters of the hash code are present.
{%#assert:intEquals /6/{%@snip SnipCheck_MIN_LINE /(\d+)/%}/fix the number written out in the next line%}\
However, you have to specify at least six characters to ensure consistency.
You have one to the ten million chance to change the snippet and get the same hash using six characters.
It is reasonably safe, but you can go safer listing more characters.

It is a considerable practice to include some instruction into the error message helping the maintainer.
You can do that using the option `message`.
The string of this option will be part of the error message.
For example, this document includes some lines similar to the following ones.

[source]
----
{@snip:check hash=72415fa846e6f
             file=src/main/java/javax0/jamal/snippet/SnipCheck.java
             message="Review the whole chapter of 'snip:check'"
}\
----

When you create the documentation of some code, you should follow the steps:

1. Enclose the parts of the code documented between `snippet NAME` and `end snippet`, or use complete files.

2. Insert the `{@snip:check hash="" id=NAME}` macro into the parts of the documentation where the pieces are documented.
Do not be afraid to copy and paste the macro.
In this case, copy-pasting is allowed, as the aim of this macro is to increase redundancy.

3. Run the macro processing.
It will eventually result in an error.
The error message will include the hash code.
Copy at least six characters to the macro, like `{@snip:check hash=af6ed3 id=NAME}`.
If you use more than one `snip:check` in your documents, using different parts of the hash code is recommended.
It will later help navigation when you search for the specific part of the document.

4. Rerun the macro processing.

When you update the documentation, and you get an error like

[source,text]
----
javax0.jamal.api.BadSyntaxAt: The file(src/main/java/javax0/jamal/snippet/SnipCheck.java)
hash is 'fa58557b.9735f98d.31c87ea5.074bd7f5.064ec63f.ec447a7e.58b8f969.958e5d4f' does not contain 'fa58557b9735f98k'.
'Review the whole chapter of 'snip:check'' at ../jamal-snippet/README.adoc.jam/435:14
----

then you have to do the following steps.

1. Look at the documentation around where the macro is.
The wrong hash code included in the error message will help you.
Use text search in the files looking for the hex code.
It should be reasonably unique.
Update the documentation to follow the change of the code part.

2. Update the hash code in the macro to the new value.

3. Rerun the macro processing.

[NOTE]
====
The error message contains the 64 character hex code as eight times eight characters dot-separated.
It helps you select a part of the code when you copy the new code into the documentation after the update.
It also helps you select different parts if you want to have more than one reference to the hash code.
The dots are not part of the code and are printed only for convenience and ignored when comparing.
You can use as many or as few dots in the hash code as you like.

The hash code is displayed using lower case hexadecimal characters, but you can use upper case or mixed case characters.
Before the check, the dots are removed, and the characters are converted to lower case.
====

In some rare cases, you do not want to check all the modifications of the file.
You specify the option `lines` to check the number of lines in the snippet or file has not changed.
To do that, you can

[source,text]
----
{@snip:check lines=22 id=snippet1,snippet2}
----

and the macro will not error so long as long the snippet or the file contains exactly 22 lines.

You can specify both the `lines` and the `hash` together, but it does not make much sense.
The macro will check the hash value first.
If the hash value fails, the macro results an error.
If the hash value is correct, the file or snippet is identical, meaning it has the same number of lines as before.

[[snipList]]
==== {%macroChapter%}`snip:list`

This macro lists the defined snippets.
The list is represented as comma-delimited, which contains the names of the snippets.

There are four parameters the macro handles; all are optional:

* `name` (can be aliased as `id`) for the name of the snippet

* `file` for the file name of the snippet

* `text` for the content of the snippet

* `listSeparator` can redefine the list separator. The default is the comma.

The first three parameters are interpreted as regular expressions.
If any missing or empty string, then the parameter is not taken into account.

The listing will filter the snippets to include only those into the list that

* the name of the snippet matches the parameter `name`, and

* the file name from which we harvested the snippet matches the parameter `file`, and

* at least one line of the snippet matches the parameter `text`.

The matching means that the regular expression should match part of the text.
If you want to match the full name, file name, or content line, you have to use a `^ ... $` format regular expression.

If all the parameters are missing, then the macro will list all the snippet names.

[[trimLines]]
==== {%macroChapter%}`trimLines`

This macro can cut off the unneeded spaces from the start and end of the lines.
When you include a code fragment in the documentation as a snippet, the lines may have extra spaces at the start.
It is the case when the fragment comes from a code part somewhere in the middle of a tabulated structure.
This macro can remove the extra spaces from the start of the line keeping the relative tabulation of the lines.
The code formatting remains the same as the source code, but the macro will align the code sample to the left.

The syntax of the macro is:

[source]
----
{@trimLines ...

  possible
    multiple lines
}
----

For example:

{%untrimmedSample/
{@trimLines
  k
   a
   b
 c
}
%}

will result

{%untrimmedOutput%}

The lines to be trimmed should start on the line following the name of the macro.
The characters following the macro name to the end of the line are parsed for options.
Options currently are:

* `margin` can specify the minimum number of spaces that appear in front of every line.
You can even insert extra spaces in front of the lines while keeping the tabulation using this option.

* `trimVertical` is a boolean parameter to remove the new line character from the sample's start and end.
It eliminates the leading and trailing empty lines.

* `verticalTrimOnly` (alias `vtrimOnly`) instructs the macro to do only the vertical trimming.
If this option is defined, there is no need to define `trimVertical` also.

The macro can also delete the empty lines from the start and the end of its input if the option `trimVertical` is set.
For example

{%untrimmedSample/
{#trimLines
{@options trimVertical}



  k
   a
   b
  c


}
%}

will result

{%untrimmedOutput%}

[[numberLines]]
==== {%macroChapter%}`numberLines`

This macro can put numbers in front of the lines, sequentially numbering them.
The syntax of the macro is

[source]
----
{@numberLines
     ..
     ..
     ..
}
----

By default, the numbering of the lines starts with one, and every line gets the next number.
For example

{%sample/
{@numberLines
this is the first line
this is the second line
this is the third line
}
%}

will result
{%#snip:define numberedLines1={%output%}%}\

{%@snip numberedLines1
[source]
----
1. this is the first line
2. this is the second line
3. this is the third line
----
%}

The macro will insert the number with a `.` (dot) after the number and space.

The parameters `start`, `step`, and `format` can define different start values, step values, and formats for the numbers.
For example

{%sample/
{#numberLines start=3 step=2 format=" %03d::"
this is the first line
this is the second line
this is the third line
}
%}

will result
{%#snip:define numberedLines2={%output%}%}\

{%@snip numberedLines2
[source]
----
003::this is the first line
005::this is the second line
007::this is the third line
----
%}

The standard Java method `String::format` will format the number using the formatting string.
Any illegal formatting will result in an error.

[[killLines]]
==== {%macroChapter%}`killLines`

This macro deletes, or keeps the selected lines from its input.
{%parameterized%}

The format of the macro is

[source]
----
{@killLines parameters

 ...

}
----

The default behavior of the macro is to delete the empty lines.
In that case it removes all lines that contain only spaces or nothing at all.

The parameter macro `pattern` may define a regular expression to select the lines.

For example:

{%sample/
{#killLines pattern=^\s*//
/* this stays */
// this is some C code that we want to list without the
// single line comments

#define VERSION 1.0 //this line also stays put
int j = 15;
}
%}

creates the output

{%output%}

If the option `keep` is used then the lines that match the pattern are kept and the other lines are deleted.


{%sample/
{#killLines pattern=^\s*// keep
/* this stays */
// this is some C code that we want to list without the
// single line comments

#define VERSION 1.0 //this line also stays put
int j = 15;
}
%}

creates the output

{%output%}

In this case only the comment lines remained that start with `//` at the start of the line.

[[skipLines]]
==== {%macroChapter%}`skipLines`

You can use this macro to skip lines from the snippet.
It is similar to <<killLines,`killLines`>> but this macro deletes ranges of lines instead of individual lines.
The macro uses two regular expressions, named `skip` and `endSkip`.
When a line matches the line `skip`, the line and the following lines are deleted from the output until a matching `endSkip`.
The macro also deletes the lines that match the regular expressions.

For example,

{%sample/
{@skipLines
this line is there
skip this line and all other lines until a line contains 'end skip' <- this one does not count
this line is skipped
this line is skipped again
there can be anything before 'end     skip' as the regular expression uses find() and not match()
there can be more lines
}
%}

will result
{%#snip:define skipLines1={%output%}%}\

{%@snip skipLines1
[source]
----
this line is there
there can be more lines
----
%}

You can also define the regular expressions defining the parameters `skip` and `endSkip`.
For example,

{%sample/
{#skipLines {@define skip=jump\s+starts?\s+here}{@define endSkip=land\s+here}
this line is there
jump start here
this line is skipped
this line is skipped again
land                 here
there can be more lines
}%}

will result
{%#snip:define skipLines2={%output%}%}\

{%@snip skipLines2
[source]
----
this line is there
there can be more lines
----
%}

It is not an error if there is no line matching the `endSkip`.
In that case, the macro will remove all lines starting with a string matching the `skip` from the output.
There can be multiple `skip` and `endSkip` lines.
The `skip` and `endSkip` lines cannot be nested.
When there is a match for a `skip`, any further `skip` is ignored until an `endSkip`.

[[replace]]
==== {%macroChapter%}`replace`

The macro `replace` replaces strings with other strings in its input.
{%standardInput%}

It uses the first argument as the input, and then every following argument pairs as search and replace strings.
For example:

{%sample/
{@replace /the apple has fallen off the tree/apple/pear/tree/bush}
%}

will result:
{%#snip:define replace1={%output%}%}\

{%@snip replace1
[source]
----
the pear has fallen off the bush
----
%}

If the option `regex` is active, then the search string is treated as regular expressions, and the replace string may also contain replacement parts.
For example,

{%sample/
{#replace {@options regex}/the apple has fallen off the tree/appl(.)/p$1ar/tree/bush}
%}

will result in the same output
{%#snip:define replace2={%output%}%}\

{%@snip replace2
[source]
----
the pear has fallen off the bush
----
%}
but this time, the replace used regular expression substitution.

[[replaceLines]]
==== {%macroChapter%}`replaceLines`

This macro replaces strings in the input.

{%parameterized%}

It works similarly to the macro <<replace,`replace`>>.
The difference is that the `replaceLine`

* is always works with regular expressions, and

* it works on the individual lines of the input in a loop.

The difference is significant when you want to match something line by line at the start or the end of the line.
For example,

{%sample/
{@define replace=/^\s+\*\s+//}
{@replaceLines
* this can be a snippet content
* which was collected
* from a Java or C program comment
}
%}

will result
{%#snip:define replaceLines1={%output%}%}\

{%@snip replaceLines1
[source]
----
* this can be a snippet content
* which was collected
* from a Java or C program comment
----
%}

The searched regular expressions and the replacement strings have to be defined in the parameter `replace`.
This parameter can be defined inside the `replaceLines` macro.
The macro scans the value of the parameter `replace` using the <<../README.adoc#argsplit,Standard Built-In Macro Argument Splitting>>.

It is usually an error when no lines are replaced in a snippet.
Use the parameter`detectNoChange` to detect this.
If this boolean parameter is `true`, the macro will error if it changes no line.

[[counter_define]]
==== {%macroChapter%}`counter:define`

This macro defines a counter.
The counter can be used like a parameterless user-defined macro that returns the actual formatted value of the counter each time.
The actual value of the counter is modified after each use.
The format of the macro is

[source]
----
{@counter:define id=identifier}
----

The value of the counter starts with 1 by default and is increased by 1 each time the macro is used.
For example,

{%sample/
{@counter:define id=c} {c} {c} {c}
%}

will result

{%output%}

You can define the start, and the step value for the counter as well as the format.
For example,

{%sample/
{#counter:define id=c start=2 step=17} {c} {c} {c}
%}

will result

{%output%}

The format can contain the usual `String.format` format string.
In addition to that, it can also contain one of the `$alpha`, `$ALPHA`, `$roman` or `$ROMAN` literals.

{%@define alphaRomanReplace($format,$by,$number)={%@ident%}\
* `$format` will be replaced by $by for 1, 2, ... , $number counter values.%}\
{%alphaRomanReplace/$alpha/`a`, `b`, ... , `z`/26%}
{%alphaRomanReplace/$ALPHA/`A`, `B`, ... , `Z`/26%}
{%alphaRomanReplace/$roman/the lower case roman numeral format/3999%}
{%alphaRomanReplace/$ROMAN/the upper case roman numeral format/3999%}

It is an error
{%@define errorMessage($format,$number)={%@ident%}\
* if either `$format` or `{%@case:upper $format%}` is used in the format, and the value is zero, negative, or larger than $number%}
{%errorMessage /$alpha/26%}, or
{%errorMessage /$roman/3999%}.

Examples:

{%sample/
{#counter:define id=cFormatted{@define format=%03d.}}{cFormatted} {cFormatted} {cFormatted}
{#counter:define id=aFormatted{@define format=$alpha.}}{aFormatted} {aFormatted} {aFormatted}
{#counter:define id=AFormatted{@define format=$ALPHA.}}{AFormatted} {AFormatted} {AFormatted}
{#counter:define id=rFormatted{@define format=$ROMAN.}{@define start=3213}}{rFormatted} {rFormatted} {rFormatted}
{#counter:define id=RFormatted{@define format=$ROMAN.}{@define start=3213}}{RFormatted} {RFormatted} {RFormatted}
%}

The output will be

{%#snip:define counter3=
{%output%}%}\

{%@snip counter3
[source]
----
001. 002. 003.
a. b. c.
A. B. C.
MMMCCXIII. MMMCCXIV. MMMCCXV.
MMMCCXIII. MMMCCXIV. MMMCCXV.
----
%}

Sometimes you want to use the current value of the counter multiple times.
It is possible to define a macro using the counter and then use the macro referring to the value.
For example the following code

{%sample/
{@counter:define id=c}{c} {#define second={c}}{second} {second} {c}
%}

will result

{%output%}

The implemented counters, however provide a simplified approach for this.

{%sample/
{@counter:define id=c}{c} {c} {c last} {c}
%}

will have the same output:

{%output%}

In this case we used the word `last` as an argument to the counter macro `c`, which instructs the macro to return the last value without increment.

[[reflow]]
==== {%macroChapter%}`reflow`

This macro reflows the content.
The default behavior is to remove all single new-line characters replacing them with spaces.
That way, the lines will extend without wrapping around, and double newlines will separate the paragraphs.

For example:

{%sample/
{@reflow
The
short
lines
will
be put into a single line.

Empty lines are paragraph limiters.




Multiple empty lines are
converted to one.}
%}

The output will be

{%output%}

If the parameter `width` specifies a positive integer number, the macro will use it to limit the length of the lines.
For example

{%@define reflowSample=0123456789|
The
long
lines
will
be broken into words.

Empty lines are paragraph limiters.%}

{%@define REFLOW_WIDTH=10%}
{%sample/
{@reflow width={%REFLOW_WIDTH%}
{%reflowSample%}
}
%}

The output will be

{%output%}

The lines are collected and broken so that none of the lines is longer than {%REFLOW_WIDTH%}.
In some cases, limiting is not possible.
When the width is too small but still positive, some words may be longer than the given width.

{%@define REFLOW_WIDTH=1%}\
For example, setting the width to `{%REFLOW_WIDTH%}`, reflow will cut the lines into words, but it will not break the individual words.

{%sample/
{@reflow width={%REFLOW_WIDTH%}
{%reflowSample%}
}
%}

The output will be

{%output%}


The `width` parameter can be a macro option as well as a macro.
For example

{%sample/
{#reflow {@define width={%REFLOW_WIDTH%}}
{%reflowSample%}
}
%}

will have the same result as:

{%output%}

Setting the `width` to any non-positive value will remove the limit from the line length.
You may use this to override a globally set `width` macro.


[[lineCount]]
==== {%macroChapter%}`lineCount`

This macro counts the lines in the content and returns the number of lines in decimal format.

{%sample/
{@lineCount
1
2
3}
%}

results

{%output%}

[[listDir]]
==== {%macroChapter%}`listDir`

This macro lists the files in a directory and then returns the list of the formatted files.
The format of the macro is:

[source]
----
{@listDir (options) directory}
----

The parameter `directory` can be absolute or relative to the currently processed document.
The options are

* `format` specifying the format of the individual files

* `separator` to specify the separator. The default is `,` (comma).

* `grep` to specify a regular expression to filter the files based on their content.
Only the files that contain a string that matches the `grep` pattern will be listed.

* `pattern` to specify a regular expression to filter the files based on their name

* `maxDepth` is the maximum depth of recursion into subdirectories.
Specify `1` in case you do not want to recurse into subdirectories.

* `followSymlinks` to follow symbolic links

* `countOnly` returns the number of the files as a string instead of the list of the file names.

The returned names of the files and directories are comma separated by default.
This makes the use of the macro a good candidate to provide the list elements for a `for` loop.
For example,

{%sample/
{#for macroJavaFile in ({@listDir (format=$simpleName) ./src/main/java/javax0/jamal/})=
- macroJavaFile}
%}

will result

{%output%}

The macro `for` is used with the `#` character, so the macro `listDir` is evaluated before executing the `for`.
The listing of the files is recursive and is unlimited by default.
The parameter `maxDepth` can limit the recursion.
The same listing limited to 1 depth (non-recursive) is the following

{%sample/
{#for macroJavaFile in ({#listDir (format=$simpleName) ./src/main/java/javax0/jamal/
{@define maxDepth=1}})=
- macroJavaFile}
%}

will result

{%output%}

The default formatting for the list of the files is the name of the file.
The parameter `format` can define other formats.
This format can contain placeholder, and these will be replaced with actual parameters of the files.
When used in a multivariable for loop, then the format usually has the format

[source]
----
$placeholdes1|placeholder2| ... |placeholder3
----

This is because the `|` character is the default separator for the different values in a `for` macro loop.

The possible placeholders are:

{%#snip:define listDirFormats$formatted=
{%#replaceLines
{%@define replace =`\n`
^\s*"(.*?)".*//\s*(.*)$
* `$1` will be replaced by the $2
OTF
of the file.
TITF
string literal `true` if the file
FO
`false` otherwise.
%}
{%#snip listDirFormats%}%}%}

{%@snip listDirFormats$formatted

* `$size` will be replaced by the size of the file.
* `$time` will be replaced by the modification time of the file.
* `$absolutePath` will be replaced by the absolute path of the file.
* `$name` will be replaced by the name of the file.
* `$simpleName` will be replaced by the simple name of the file.
* `$isDirectory` will be replaced by the string literal `true` if the file is a directory, `false` otherwise.
* `$isFile` will be replaced by the string literal `true` if the file is a plain file, `false` otherwise.
* `$isHidden` will be replaced by the string literal `true` if the file is hidden, `false` otherwise.
* `$canExecute` will be replaced by the string literal `true` if the file can be executed, `false` otherwise.
* `$canRead` will be replaced by the TIFT can be read, `false` otherwise.
* `$canWrite` will be replaced by the string literal `true` if the file can be written, `false` otherwise.
%}

For example,

{%sample/
{!#for (name,size) in ({#listDir ./src/main/java/javax0/jamal/
{@define format=$simpleName|$size}
})=
- name: {`@format /%,d/(int)size} bytes}
%}

will result
{%#snip:define listDir3=
{%output%}%}\

{%@snip listDir3
[source]
----
- jamal: 96 bytes
- snippet: 1,056 bytes
- Snip.java: 2,302 bytes
- Case.java: 2,273 bytes
- NumberLines.java: 2,151 bytes
- DateMacro.java: 613 bytes
- Format.java: 930 bytes
- Update.java: 3,772 bytes
- FilesMacro.java: 4,791 bytes
- Collect.java: 8,007 bytes
- TrimLines.java: 3,687 bytes
- LineCount.java: 604 bytes
- Replace.java: 1,775 bytes
- SnipXml.java: 1,489 bytes
- Counter.java: 3,691 bytes
- StringMacros.java: 5,828 bytes
- Clear.java: 434 bytes
- KillLines.java: 1,532 bytes
- SnippetStore.java: 9,845 bytes
- ListDir.java: 5,220 bytes
- XmlFormat.java: 3,317 bytes
- XmlInsert.java: 6,199 bytes
- SnipProperties.java: 1,485 bytes
- Xml.java: 1,543 bytes
- CounterMacro.java: 1,811 bytes
- SnipList.java: 1,233 bytes
- XmlDocument.java: 4,044 bytes
- Java.java: 9,275 bytes
- ReplaceLines.java: 2,299 bytes
- SkipLines.java: 2,048 bytes
- SnipCheck.java: 5,219 bytes
- Reflow.java: 1,716 bytes
- Snippet.java: 1,088 bytes
----
%}

If the option `followSymlinks` is used, like in

[source]
----
{@options followSymlinks}
----

then the recursive collection process for collecting the files will follow symlinks.

The separator character between the formatted items is a comma by default.
The option `separator` or its alias `sep` can modify it.
For example the example:

{%sample/
{#listDir (format=$simpleName maxDepth=1 sep=*) ./src/main/java/javax0/jamal/}
%}

will result

{%output%}

[[xmlFormat]]
==== {%macroChapter%}`xmlFormat`

The macro `xmlFormat` interprets the input as an XML document if there is any, resulting in the formatted document.
If the input is empty or contains only spaces, it registers a post-processor that runs after the Jamal processing and formats the final output as XML.
For example,

{%sample/
{#xmlFormat
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion><name>jamal snippet</name><packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId><artifactId>jamal-snippet</artifactId><version>{%VERSION%}</version>
</project>
}
%}

will result
{%#snip:define tabulatedXmlFormat=
{%output%}%}\

{%@snip tabulatedXmlFormat
[source]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <name>jamal snippet</name>
    <packaging>jar</packaging>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>1.10.2-SNAPSHOT</version>
</project>
----
%}

The default tabulation size is four.
You can alter it by defining the parameter `tabsize`.
For example,

{%sample/
{#xmlFormat
<?xml version="1.0" encoding="UTF-8" standalone="no"?>{@define tabsize=0}
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion><name>jamal snippet</name><packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId><artifactId>jamal-snippet</artifactId><version>{%VERSION%}</version>
</project>
}
%}

will result
{%#snip:define zeroTabulatedXmlFormat=
{%output%}%}\

{%#snip zeroTabulatedXmlFormat
[source]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion>
<name>jamal snippet</name>
<packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId>
<artifactId>jamal-snippet</artifactId>
<version>1.10.2-SNAPSHOT</version>
</project>
----
%}

As you can see, there is no tabulation in this case.

There is another use of the macro `xmlFormat`.
If you do not include any XML or anything else into the macro as input, the macro will treat this as a command to format the whole output.
It registers itself into the processor, and when the processing is finished, this registered call-back starts.
At that point, it will format the output of the processing.
That way, you can easily format a whole processed file.

The previous example that we used before can also be formulated this way.

{%sample/
{#xmlFormat}
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion><name>jamal snippet</name><packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId><artifactId>jamal-snippet</artifactId><version>{%VERSION%}</version>
</project>
%}

Note that the macro invocation `{#xmlFormat}` in this case can be anywhere in the input.
The formatting will take place postponed when the processing is finished.
It will result in the same output as before:
{%#snip:define tabulatedXmlFormat1=
{%output%}%}\

{%@snip tabulatedXmlFormat1
[source]
----
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <name>jamal snippet</name>
    <packaging>jar</packaging>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>1.10.2-SNAPSHOT</version>
</project>
----
%}

[[date]]
==== {%macroChapter%}`date`

This macro will return the current date formatted using Java `SimpleDateFormat`.
The format string is the input of the macro.

Example

{%sample/
{@date yyyy-MM-dd HH:mm:ss}
%}

will result in the output

{%#snip:define dateOutput={%output%}%}\
{%@snip dateOutput%}

[[format]]
==== {%macroChapter%}`format`

You can use the macro `format` to format the arguments.
{%standardInput%}

The first argument will be interpreted as the format string.
The rest of the arguments will be used as the values for the formatting.
By the nature of Jamal, all these arguments are strings.
Since the parameters to the underlying `String::format` method are not only strings, they can be converted.
If any of the parameters starts with a `(xxx)` string, then the string will be converted to the type`xxx` before passing to `String::format` as an argument.
This format is similar to the cast syntax of Java and C.

The `xxx` can be

{%!@for type in (int,long,double,float,boolean,short,byte)=
* `type`, the conversion will call {%#case:cap {%@replace /type/int/integer%}%}::parse{%@case:cap type%}.%}
* `char`, the conversion will fetch the first character of the parameter.

Examples:

{%sample/
{@define LONG=5564444443455587466}
{@format /%,016d/(int)  587466}
{#format /%x/(long){LONG}}}
{@format /%,016.4f/(double)587466}
{@format /%e/(double)587466}
{@format /%e is %s/(double)587466/5.874660e+05}
{#format /hashCode(0x%x)=0x%h/(long){LONG}/(long){LONG}}
%}

will result in the output

{%#snip:define formatOutput={%output%}%}\
{%@snip formatOutput
[source]
----
000000000587,466
4d38e0bd5891048a}
0000587,466.0000
5.874660e+05
5.874660e+05 is 5.874660e+05
hashCode(0x4d38e0bd5891048a)=0x15a9e437
----
%}

[[case]]
==== {%macroChapter%}`case:lower`, `case:upper`, ...

There are a few character case-changing macros implemented in the snippet package.
These are:

{%@define case(lower)=* `case:lower` changes the characters in the input to lower case letters%}
{%case lower%}
{%case upper%}
{%@define case(cap,upper)=* `case:cap` changes the first character in the input to upper case letter%}
{%case/cap/upper%}
{%case/decap/lower%}

[[file]]
==== {%macroChapter%}`file`
{%@define fileDirectory($what)=
You can use this macro to include the name of a $what in the documentation.
First, it seems counterintuitive to have a macro for that.
You can type in the name of the $what, and it will appear in the output.

The real added value of the macro is that it checks that the $what exists.
The macro will error if the $what does not exist or is not a $what.
It helps the maintenance of the documentation.
If the $what gets renamed, moved, or deleted, the document will not compile until you follow the change.

The macro can also format the name of the $what.
It uses the value of the user-defined macro `$whatFormat` for the purpose.
If this macro is defined outside the `$what` macro, then the $what names will be formatted using the same format.
For example, you can write%}\
{%fileDirectory file%}

{%sample/
When Jamal processes this file it will generate {@file (format=`$name`)README.adoc}.
%}

will result

{%#snip:define fileOutput={%output%}%}\
{%@snip fileOutput
[source]
----
When Jamal processes this file it will generate `README.adoc`.
----
%}

{%@define replace=|^.*?"(.*?)"|* `$1`!|!.*?//||%}\
{%@define pattern=\)\.and\(%}\
In the format you can use the following placeholders:
{%#snip:define fileMacroFormatPlaceholdersFormatted=
{%#replaceLines
{%#killLines
{%@snip fileMacroFormatPlaceholders %}%}%}%}

{%@snip fileMacroFormatPlaceholdersFormatted
* `$name` gives the name of the file as was specified on the macro
* `$absolutePath` the absolute path to the file
* `$parent` the parent directory where the file is
* `$canonicalPath` the canonical path
%}

[[directory]]
==== {%macroChapter%}`directory`
{%fileDirectory directory%}

{%sample/
This file is in the directory {@define directoryFormat=`$name`}{@directory ../jamal-snippet}.
%}

will result

{%#snip:define dirOutput={%output%}%}\
{%@snip dirOutput
[source]
----
This file is in the directory `../jamal-snippet`.
----
%}

In the format you can use the following placeholders:
{%#snip:define dirMacroFormatPlaceholdersFormatted=
{%#replaceLines
{%#killLines
{%@snip dirMacroFormatPlaceholders %}%}%}%}

{%@snip dirMacroFormatPlaceholdersFormatted
* `$name` gives the name of the directory as was specified on the macro
* `$absolutePath` gives the name of the directory as was specified on the macro
* `$parent` the parent directory
* `$canonicalPath` the canonical path
%}


[[Java]]
==== {%macroChapter%}Java Macros

[[java:class]]
===== `java:class`

{%@define classMethodMacroIntro($x)=
The macro `java:$x` checks that the parameter is a valid Java $x and found on the classpath.
It is an error if the class is not on the classpath.
This macro is useful when you document Java source code and run the Jamal conversion from a unit test.
In this case, the macro will see the test and main classes.
It can check that the $x mentioned in the documentation is still there; it was not deleted or renamed.%}\
{%classMethodMacroIntro class%}

The output of the macro is the class formatted.
The formatting is the simple name of the class by default.
The formatting can be defined by the parameter `classFormat`.
For example:

{%sample/
The class that implements the macro `java:class` is
{@java:class javax0.jamal.snippet.Java$ClassMacro}.
%}

will result in the output

{%#snip:define class1={%output%}%}\
{%@snip class1
[source]
----
The class that implements the macro `java:class` is
ClassMacro.
----
%}

The format string can be any string with `$` prefixed placeholders.
The placeholders that the macro handles are:
{%@define replace=/^\s*"(.*)"\s*,\s*klass\.(.*)\(\),?$/* `$1` will be replaced by the result of calling `$2()`%}
{%#snip:define classFormatFormatted={%#replaceLines
{%@snip classFormats%}%}%}
{%@snip classFormatFormatted
* `$simpleName` will be replaced by the result of calling `getSimpleName()`
* `$name` will be replaced by the result of calling `getName()`
* `$canonicalName` will be replaced by the result of calling `getCanonicalName()`
* `$packageName` will be replaced by the result of calling `getPackageName()`
* `$typeName` will be replaced by the result of calling `getTypeName()`
%}

For example

{%sample/
The class that implements the macro `java:class` is
{@define classFormat=$canonicalName}\
{@java:class javax0.jamal.snippet.Java$ClassMacro} with the canonical name, and
{@define classFormat=$name}\
{@java:class javax0.jamal.snippet.Java$ClassMacro} with the "normal" name.
It is in the package {#java:class javax0.jamal.snippet.Java$ClassMacro {@define classFormat=$packageName}}
{@java:class javax0.jamal.snippet.Java$ClassMacro} is still the "normal" name,
format defined inside the macro is local.
%}

will result in the output

{%#snip:define class2={%output%}%}\
{%@snip class2
[source]
----
The class that implements the macro `java:class` is
javax0.jamal.snippet.Java.ClassMacro with the canonical name, and
javax0.jamal.snippet.Java$ClassMacro with the "normal" name.
It is in the package javax0.jamal.snippet
javax0.jamal.snippet.Java$ClassMacro is still the "normal" name,
format defined inside the macro is local.
----
%}

It is not recommended to overuse the format string.
Do not include verbatim text into the format string.
Choose a format string you want to refer to the classes and use it globally in the document.

[[java:field]]
===== `java:field`

{%classMethodMacroIntro field%}
In addition to that the value of the value of the field can also be used in the formatting in case the field is both `static` and `final`.
{%sample/
{@define field=javax0.jamal.api.SpecialCharacters#PRE_EVALUATE}
The field {#java:field (format="$name") {field}}
defined in the class {#java:field (format="$className") {field}}
is both `static` and `final` and has the value {#java:field (format="$value") {field}}
%}

will result in the output

{%output%}

The format string can be any string with `$` prefixed placeholders.
The placeholders that the macro handles are:
{%@define replace=`\n`
^.*?"(.*?)".*//\s*(.*)$
* `$1` will be replaced by the $2
OTFDC
of the fields's defining class
OTF
of the field
\).and\(
%}
{%#snip:define fieldFormatFormatted={%#replaceLines
{%@snip fieldFormats%}%}%}
{%@snip fieldFormatFormatted
* `$name` will be replaced by the name of the field
* `$classSimpleName` will be replaced by the simple name of the fields's defining class
* `$className` will be replaced by the name of the of the fields's defining class
* `$classCanonicalName` will be replaced by the canonical name of the fields's defining class
* `$classTypeName` will be replaced by the type name of the fields's defining class
* `$packageName` will be replaced by the package where the method is
* `$typeClass` will be replaced by the type of the field
* `$modifiers` will be replaced by the modifiers list of the method
                
* `$value` will be replaced by the value of the field in case the field is both `static` and `final`
%}

[[java:method]]
===== `java:method`

{%classMethodMacroIntro method%}

The output of the macro is the method formatted.
The formatting is the name of the method by default.
The formatting can be defined by the parameter `methodFormat`.
For example:

{%sample/
{@define method=/javax0.jamal.snippet.Java$MethodMacro/evaluate}\
{#java:method {method}}
%}

will result in the output

{%#snip:define method1={%output%}%}\
{%@snip method1
[source]
----
evaluate
----
%}

The macro can have two arguments, using the <<../README.adoc#argsplit,Standard Built-In Macro Argument Splitting>> or one, specifying the full name of the method.
The method's full name is the class's full name, and the method name separated by either a `#` character or by `::` characters.

The format string can be any string with `$` prefixed placeholders.
The placeholders that the macro handles are:
{%@define replace=`\n`
^.*?"(.*?)".*//\s*(.*)$
* `$1` will be replaced by the $2
OTMDC
of the method's defining class
OTM
of the method
%}
{%#snip:define methodFormatFormatted={%#replaceLines
{%@snip methodFormats%}%}%}
{%@snip methodFormatFormatted
* `$classSimpleName` will be replaced by the simple name of the method's defining class
* `$className` will be replaced by the name of the of the method's defining class
* `$classCanonicalName` will be replaced by the canonical name of the method's defining class
* `$classTypeName` will be replaced by the type name of the method's defining class
* `$packageName` will be replaced by the package where the method is
* `$name` will be replaced by the name of the method
* `$typeClass` will be replaced by the return type of the method
* `$exceptions` will be replaced by the comma separated values of the exception types the method throws
* `$parameterTypes` will be replaced by the comma separated parameter types
* `$parameterCount` will be replaced by the number of the parameters in decimal format
* `$modifiers` will be replaced by the modifiers list of the method
%}

These formats can be used in your macros directly or using the macros defined in the jim file `res:snippet.jim`.
For example,

{%sample/
The class that implements the macro `java:method` is '{#java:method {method}{@define methodFormat=$name}}()',
but it is simpler to import the jim file included in the snippet library

            {@import res:snippet.jim}\

and use the user defined macros, like the following:

{java:method:modifiers |{method}}\
{java:method:classSimpleName |{method}}\
::{java:method:name |{method}}({java:method:parameterTypes:simpleName |{method}})
%}

will result in the output

{%#snip:define method2={%output%}%}\
{%@snip method2
[source]
----
The class that implements the macro `java:method` is 'evaluate()',
but it is simpler to import the jim file included in the snippet library


and use the user defined macros, like the following:

publicMethodMacro::evaluate(Input,Processor)
----
%}

[[String]]
==== {%macroChapter%}String Macros

[[string:contains]]
===== `string:contains`

This macro returns the string `true` if the input contains a text given as a parameter and the text `false` otherwise.
The macro handles two parameters:

* `text` (alias `string`) must be present, and it should specify the string to find in the input.

* `regex` is an optional parameter.
If it is `true`, then the text will be interpreted as a regular expression.
The macro will check if a match is found inside the input.
(It calls the Java regular expression matcher `find()`.)

[[string:quote]]
===== `string:quote`

This macro returns the input of the macro quoted.
You can use the string inside another string that way.
This macro is useful when the output is used as some programming language source.
Example:

{%sample/
{@string:quote This "is" quoted '
 new line is also quoted, tabs are also and line-feed also \ becomes doubled}
%}

will result

{%output%}

The actual conversions performed are:

* `\` -> `\\`
* tab -> `\t`
* back space -> `\b`
* new line -> `\n`
* line feed -> `\r`
* form feed -> `\f`
* `"` -> `\"`

[[string:equals]]
===== `string:equals`

This macro returns the string literal `true` or `false` comparing the two arguments.
It returns `true` if the two arguments are equal and `false` otherwise.
If the option `ignoreCase` is used, then the comparison is made ignoring the character casing.

Example:

{%sample/
{@string:equals/aaa/aaa}
{@string:equals/aaa/bbb}
%}

will result

{%output%}


[[string:startsWith]]
===== `string:startsWith`

This macro returns the string literal `true` or `false` comparing the two arguments.
It returns `true` if the first argument starts with the second argument and `false` otherwise.

Example:

{%sample/
{@string:startsWith/aaa/aa}
{@string:startsWith/aaa/ba}
%}

will result

{%output%}

[[string:endsWith]]
===== `string:endsWith`

This macro returns the string literal `true` or `false` comparing the two arguments.
It returns `true` if the first argument ends with the second argument and `false` otherwise.

Example:

{%sample/
{@string:endsWith/aaa/aa}
{@string:endsWith/aaa/ab}
%}

will result

{%output%}

[[string:reverse]]
===== `string:reverse`

This macro returns the reverse of the input string.
For example:

{%sample/
{@string:reverse 0123456789abcdefgh}
%}

will result

{%output%}

[[string:substring]]
===== `string:substring`

This macro returns a substring of the input.
The parameters are

* `begin` specifying the beginning of the substring (default is the start of the string), and

* `end` specifying the end of the substring (default is the end of the string).

If any of the parameters is a negative number, then the macro calculates the position from the end of the string.

Examples:

{%sample/
{@string:substring the whole string}
{@string:substring (begin=0 end=3)the first three character} only the'
{@string:substring (begin=1 end=-1)ythea}
%}

will result

{%output%}

[[string:length]]
===== `string:length`

This macro returns the length of the input.
The parameters are:

* `trim` tells the macro that the input has to be trimmed before calculating the length

* `left` tells the macro that the trimming has to be applied to the start (left) of the input

* `right` tells the macro that the trimming has to be applied to the end (right) of the input

You can use `left` and `right` together with `trim`.
It will have the same effect as using `trim` alone.
Using either `left` or `right` without trim is an error.

[[snip_update]]
==== {%macroChapter%}`snip:update`

This macro can be used to automatically copy the content of the snippets into the `snip` macros.
That way, the Jamal source will contain an updated value of the snippet helping the navigation in the Jamal source file.

The result of the macro is an empty string, and it has no side effect inside the macro processor.
When it does, however, is that it alters the file it was used in inserting the snippets into the comment part of the `snip` macro.
Its operation is done in three steps:

1. Reads the file into the memory.
2. It goes through all the lines and inserts the snippet's content into the comment part of the `snip` macros.
If there is already a comment there, then it gets deleted and replaced.
3. Writes the altered content into the original file updating it.

This macro alters the original file; therefore, its use has to be performed with great care.
Ensure that you save the original file before executing Jamal, making a copy of it or committing it into the git repository.

The `snip:update` macro does not perform Jamal syntax analysis.
To use this macro successfully, you have to follow the additional rules:

* The `{@snip id...` macro should start on a new line.
There may be spaces before the macro.
There must not be a comment on the same line following the snipped identifier.
You can put a few non-space characters after the snippet identifier if you want to exclude a snippet use from the update.

* The `snip` macro matching macro closing string has to be on a separate line.
There may be spaces before and after the closing string, but nothing else.

You can customize the `update` macro.
If the macros `start` and/or `stop` are defined, their value will be used as a regular expression to find the beginning, and the end of the snippet content insertion points.
The default value for `start` is

    ^\s*\Q{\E\s*(?:#|@)\s*snip\s+([$_:a-zA-Z][$_:a-zA-Z0-9]*)\s*$

When this pattern is calculated, the current macro opening string is used instead of `{`.
The `stop` string is

    ^\s*\Q}\E\s*$

When this pattern is calculated, the current macro closing string is used instead of `}`.

(The `\Q` and `\E` escape sequences in Java regular expressions denote escaping, so that the characters between are matched literally.)

It is also possible to define a `head` and `tail` macro.
The content of the `head` macro will be copied in front of the inserted snippet.
The content of the `tail` macro will be copied after the inserted snippet.
It can be used to insert, for example, asciidoc

   [source]
   ----

header and

   ----

footer when the snippets are code samples in an asciidoc file.

{%@snip:update%}
