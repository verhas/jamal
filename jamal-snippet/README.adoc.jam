= Jamal Snippet Handling Macros
{%@import res:jamal.jim%}\
{%@import ../shared_text.jim%}\
{%@import documentation/doc.jim%}
{%@import [global] ../RELEASES.jim%}\
{%@snip:collect onceAs="MAIN" from="src/main/java/"%}\
{%@snip:collect onceAs="SAMPLE" from="src/test/java/" exclude="Sample.java"%}\
{%#define lastUpdated={%@date yyyy-MM-dd HH:mm:ss%}%}\
{%#snip:define lastUpdated={%lastUpdated%}%}\
{%@define JAVA_DIR=src/main/java/javax0/jamal/snippet/%}
{%@define ARGSPLIT=link:../documentation/ARGSPLIT.adoc[Standard Built-In Macro Argument Splitting]%}
{%@define standardInput= The macro scans the input using the {%ARGSPLIT%}.%}
{%@define alias(x)=(can be aliased as `x`)%}
{%@options detectNoChange%}
{%@define CHPREFIX====%}

Snippet handling macros help you to include information from program source code into the documentation automatically.
This macro package also includes some XML handling, string, and text formatting macros, which are usually used together with snippets.

When you document an application, there is a lot of information that changes by changing the source code.
These changes have to be followed in the documentation.
Some changes need manual editing.
Some changes can be automated.
When the program functionality changes, the changed documentation has to describe the new functionality.
We can hardly automate this change of documentation.
When some literal parameter also used in the document changes, then Jamal can automatically update the documentation.
A typical example is the version number of the application.
The documentation many times may refer to the latest version.

For example, if you want to use the latest version of Jamal Snippet macro as a dependency in a `pom.xml` file then you have to have the lines:

{%@snip:xml pom=pom.xml%}\
{%#define VERSION={%pom /project/version/text()%}%}\
[source,xml]
----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{%VERSION%}</version>
</dependency>
----

You see in the `README.adoc` file the actual version number converted from the `README.adoc.jam`.
The original file, however, contains

[source,xml]
----
{%@escape* ``{%@snip:xml pom=pom.xml%}\
{%#define VERSION={%pom /project/version/text()%}%}
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{%VERSION%}</version>
</dependency>``%}
----

The Jamal Snippet macros help you automate to insert actual, and transformed values, text fragments from

* any source code
* XML file
* properties files.

These small text pieces are called snippets.

When the `.jam` file gets processed, the snippets will automatically contain the source code's actual text.
This way, it is easier to keep your documentation up to date.

== Table of contents

. <<usage,Usage>>
. <<macros,Macros>>
[lowerroman, start=1]
.. <<snip_collect,`snip:collect`>>
.. <<snip_properties,`snip:properties`>>
.. <<snip_xml,`snip:xml`>>
.. <<xml_define,`xml:define`>>
.. <<xml_insert,`xml:insert`>>
.. <<snip_define,`snip:define`>>
.. <<snip_clear,`snip:clear`>>
.. <<snip,`snip`>>
.. <<snip_check,`snip:check`>>
.. <<snipList,`snip:list`>>
.. <<snipSave,`snip:save`>>
.. <<snipLoad,`snip:load`>>
.. <<trimLines,`trimLines`>>
.. <<untab,`untab`>>
.. <<range,`range`>>
.. <<Base64,`base64`>>
.. <<repeat,`repeat`>>
.. <<rot13,`rot13`>>
.. <<def,`def`>>
.. <<urlencode,`urlencode`>>
.. <<pos,`pos`>>
.. <<sort,`sort`>>
.. <<numberLines,`numberLines`>>
.. <<killLines,`killLines`>>
.. <<skipLines,`skipLines`>>
.. <<replace,`replace`>>
.. <<replaceLines,`replaceLines`>>
.. <<counter_define,`counter:define`>>
.. <<references,`references`>>
.. <<reflow,`reflow`>>
.. <<snipLine,`snip:line`>>
.. <<snipFile,`snip:file`>>
.. <<snipEval,`snip:eval`>>
.. <<snipTransform,`snip:transform`>>
.. <<lineCount,`lineCount`>>
.. <<listDir,`listDir`>>
.. <<xmlFormat,`xmlFormat`>>
.. <<thinXml,`thinXml`>>
.. <<date,`date`>>
.. <<format,`format`>>
.. <<numbers,`numbers`>>
.. <<unicode,`unicode`>>
.. <<case,`case:lower`, `case:upper`, ...>>
.. <<locate,`file:locate`>>
.. <<dev_root,`dev:root`>>
.. <<file,`file`>>
.. <<directory,`directory`>>
.. <<Java,Java Macros>>
... <<java:class,`java:class`>>
... <<java:field,`java:field`>>
... <<java:method,`java:method`>>
... <<java:sources,`java:sources`>>
... <<java:classes,`java:classes`>>
... <<java:methods,`java:methods`>>
... <<java:fields,`java:fields`>>
... <<java:insert,`java:insert`>>
.. <<String,String Macros>>
... <<string:contains,`string:contains`>>
... <<string:quote,`string:quote`>>
... <<string:equals,`string:equals`>>
... <<string:startsWith,`string:startsWith`>>
... <<string:endsWith,`string:endsWith`>>
... <<string,`string`>>
... <<string:reverse,`string:reverse`>>
... <<string:substring,`string:substring`>>
... <<string:between,`string:between`>>
... <<string:before,`string:before`>>
... <<string:after,`string:after`>>
... <<string:length,`string:length`>>
... <<string:chop,`string:chop`>>
.. <<shell:var,`shell:var`>>
.. <<hashCode,`hashCode`>>
.. <<memoize,`memoize`>>
.. <<download,`download`>>
.. <<dictionary,`dictionary`>>
.. <<decorate,`decorate`>>
.. <<snip_update,`snip:update`>>
.. <<variation,`variation`>>
.. <<plural,`plural`>>
. <<kroki,Kroki>
{%@counter:define hierarchical id=chapter format=%d.{2:$ROMAN} %}

[[usage]]
== {%chapter%}Usage

If you are using Jamal programmatically or from Maven then the dependency you have to add to your project is:

----
<dependency>
    <groupId>com.javax0.jamal</groupId>
    <artifactId>jamal-snippet</artifactId>
    <version>{%VERSION%}</version>
</dependency>
----

The macro classes are listed in the `provides` directive in the `module-info.java`; therefore, they are available for the Jamal processor when the JAR file is on the path (class or module).
There is no need to invoke the `use` command to get access to these macros.

[[macros]]
== {%chapter%}Macros

{%chapter open%}{%@define chapter$format={2:$ROMAN. }%}\
{%@define CH($X,$Y)=
[[$X]]
=== {%chapter%}`$Y`

{%@include documentation/macros/$X.adoc.jam%}%}

{%CH /snip_collect/snip:collect%}
{%CH /snip_properties/snip:properties%}
{%CH /xml_define/xml:define%}
{%CH /snip_xml/snip:xml%}
{%CH /xml_insert/xml:insert%}
{%CH /snip_define/snip:define%}
{%CH /snip_clear/snip:clear%}


[[snip]]
=== {%chapter%}`snip`
{%#snip:check file={%JAVA_DIR%}Snip.java hash=5c4a28e1%}

You can use the `snip` macro to insert one or more snippets into the output.
There are three different ways to use the macro.

. insert a single snippet into the output with the full text of the snippet

. insert a part of the first line of a snippet into the output

. insert multiple snippets into the output.

In all of these cases the option `hash` or `hashCode` can be used to perform a consistency check.
It works exactly the same way as in the macro <<snip_check,`snip:check`>>.
The possibility to have this option eliminates the need to use the `snip` and the `snip:check` macros together.
Note, however, that it is not possible to check against the number of the lines in the snippet.
You can check only the hash code.

You can also use any of the options of the macro <<snipTransform,`snip:transform`>>.
The macro `snip` will automatically apply the transformations calling the macro `snip:transform`.

=== Use one snippet

The syntax for the first case is

[source]
----
{@snip snipped_id comment}
----

The result of the macro is the content of the snippet named `snipped_id`.
The macro reads the snippet identifier from the input, and it purposefully ignores the rest when used without the option `poly`.
The reason to have the rest of the input as the comment is to allow the Jamal file users to insert a description of the snippet.
You can manually copy the content of the snippet there, which helps the navigation in the source code, but at the same time, it may not be a problem if the copy gets outdated.
You can use the macro <<snip_update,snip_update>> to update the snippet's content in the Jamal source file.
Since that macro modifies the file you edit, you must use it with care.

Since the introduction of the Asciidoctor preprocessor and the WYSIWYG editing possibility of Asciidoc and Markdown files the importance of this feature has decreased.

=== Partial snippet

The second case uses only part of the snippet. (starting from Jamal version 1.7.2)

[source]
----
{@snip snipped_id /regular expression/}
----

If the "comment" following the snippet id starts with the `/` character, then the result of the macro is the first line of the snippet.
This line should match the regular expression, or an error is reported.
Also, the regular expression must be error-free and must have a match group.
The result of the macro will be the part of the first line of the snippet that matches the regular expression match group.
The typical use is when there is a constant defined in the code, and you want to reference the value of the constant.
In this case, you can add

[source,java]
----
// snipline snippet_id
...
----

line before defining the constant, and add a regular expression with one capturing group.
For example, you can have

[source,java]
----
// snipline defaultShellName
public static final String DEFAULT_RUBY_SHELL_NAME = ":rubyShell";
----

and the Jamal code

[source,text]
----
{#define defaultShellName={@snip defaultShellName /"(.*)"/}}\
----

to gauge out the string `:rubyShell` from the source code.

[NOTE]
====
It is also possible to specify the regular expression in the source code.
As it is documented in the section <<snip_collect,`collect`>>, the `snipLine` declaration may end with a `filter=regular expression` option.
====

When you check the snippet consistency using the option `hash` or `hashCode` the hash code of the whole snippet is calculated.
If there is any change in the snippet, even outside the first line, the hash code will be different and the snippet inclusion will purposefully fail.

=== Multiple Snippets

The third use is to insert multiple snippets into the output. (starting from Jamal 1.11.0)
In this case, the syntax is the following:

[source]
----
{@snip (poly) regular expression}
----

Note that there is no `/` around the regular expression.

The option `poly` has to be between `(` and `)` characters as usual in non-core built-in macros.

In this case, the macro collects and concatenates all snippets with regular expression matching names, and the value of the macro is the resulting text.
The snippets are sorted by their names before concatenation regardless of their appearance order in the file or files.

[NOTE]
====
This ordering is different from what you can achieve using AsciiDoc style snippet collecting.
When you do AsciiDoc style snippet collecting, you use the `tag::` name `[]` and `end::` name `[]` syntax to start and stop snippets.
A snippet can be started and stopped using the same name many times in the same file.
Following the style of AsciiDoc snippets, the collection process collects all those fragments into a single snippet.
The ordering is the same as the appearance order of the snippet fragments in the file.
The collection process does the concatenation.

When the `snip` macro is used with the option `poly`, the snippets are concatenated during the use.
The snippets may be collected from different files.
The order of the different snippets coming from separate files is not defined.
The snippets are sorted by their name before concatenation to guarantee a definite order.
It is recommended to name these snippets with a name and a number, like `my_snippet_1000`, `my_snippet_2000`, etc.
That way, the regular expression can be `pass:[my_snippet_\d{4}]`, and in case the ordering needs to be changed slightly, there is room to insert a new snippet between two already existing ones.
You may remember this technique from 40 years ago when BASIC program lines had to be numbered.
====

When used with the option `poly`, it is impossible to use any comment following the regular expression.
The whole text after the option till the macro closing string is interpreted as part of the regular expression.

When you check the snippet consistency using the option `hash` or `hashCode` the hash code of the whole text containing the snippets concatenated is calculated.
If there is

* any change in any of the snippets, or there is

* a new snippet included into the set,

* a snippet was deleted or renamed and is not included into the set any more,

* or in case the ordering of the snippets change,

* for any reason the concatenated set of snippets changes,

then snippet inclusion will purposefully fail.

=== Snippet Transformation

You can surround the snippet using the macro <<snipTransform,`snip:transform`>> transforming the output.
This is, however, such a usual case that the macro will automatically invoke the transformation.
To do this the macro `snip` will accept all the options of the macro `snip:transform` and will pass them to that.

[[snip_check]]
=== {%chapter%}`snip:check`
{%#snip:check file={%JAVA_DIR%}SnipCheck.java hash=95c2b96c%}
You can use this macro to enforce consistency between the documented system and the documentation.
Using this macro will nudge the maintainer to check the relevant parts of the document when the documented code changes.
The macro itself will not update the documentation.
It will warn with an error if some part of the documentation needs update due to changed application code.
That way, the document may remain up-to-date, and you will not forget to update it.

To use the macro, you should first select some part of the code.
This part can be one or more snippets and whole source files.
You specify file names using the `file` or `files` option of the macro.
Snippets are specified using the `id` or `ids` option.
You can define one or more files and snippets at the same time.
The values are comma-separated.

[source,text]
----
{@snip:check hash=2a4ddeab580ad1fe8c95a id=snippet1,snippet2
    file=src/main/java/javax0/jamal/snippet/SnipCheck.java,src/test/java/javax0/jamal/snippet/TestSnipCheck.java%}
----

The macro `snip:check` calculates a hashcode of the snippet.
The hashcode can also be specified in the macro option `hash` or `hashCode`.

(These hex code above is made up, `TestSnipChek.java` does not even exist.)

If this hash code is the same as the one calculated, the programmer did not change the code in the snippet.
If the codes are different, then the macro will error.
It means that the snippet or file has changed, and the documentation has to follow the change.
When the documentation is updated, you should also update the hash code.

Nothing will stop you from updating the hash code without updating the documentation, though.
It takes discipline to keep the documentation up-to-date.
This macro only helps not to forget some parts.

The hash code calculated contains 64 hexadecimal characters.
You may notice that the examples above contain less.
The macro accepts if only a few characters of the hash code are present.
{%#assert:intEquals /6/{%@snip SnipCheck_MIN_LINE /(\d+)/%}/fix the number written out in the next line%}\
However, you have to specify at least six characters to ensure consistency.
You have one to the ten million chance to change the snippet and get the same hash using six characters.
It is reasonably safe, but you can go safer listing more characters.

It is a considerable practice to include some instruction into the error message helping the maintainer.
You can do that using the option `message`.
The string of this option will be part of the error message.
For example, this document includes some lines similar to the following ones.

[source]
----
{@snip:check hash=72415fa846e6f
             file={%JAVA_DIR%}SnipCheck.java
             message="Review the whole chapter of 'snip:check'"
}\
----

When you create the documentation of some code, you should follow the steps:

1. Enclose the parts of the code documented between `snippet NAME` and `end snippet`, or use complete files.

2. Insert the `{@snip:check hash="" id=NAME}` macro into the parts of the documentation where the pieces are documented.
Do not be afraid to copy and paste the macro.
In this case, copy-pasting is allowed, as the aim of this macro is to increase redundancy.

3. Run the macro processing.
It will eventually result in an error.
The error message will include the hash code.
Copy at least six characters to the macro, like `{@snip:check hash=af6ed3 id=NAME}`.
If you use more than one `snip:check` in your documents, using different parts of the hash code is recommended.
It will later help navigation when you search for the specific part of the document.

4. Rerun the macro processing.

When you update the documentation, and you get an error like

[source,text]
----
javax0.jamal.api.BadSyntaxAt: The file(src/main/java/javax0/jamal/snippet/SnipCheck.java)
hash is 'fa58557b.9735f98d.31c87ea5.074bd7f5.064ec63f.ec447a7e.58b8f969.958e5d4f' does not contain 'fa58557b9735f98k'.
'Review the whole chapter of 'snip:check'' at ../jamal-snippet/README.adoc.jam/435:14
----

then you have to do the following steps.

1. Look at the documentation around where the macro is.
The wrong hash code included in the error message will help you.
Use text search in the files looking for the hex code.
It should be reasonably unique.
Update the documentation to follow the change of the code part.

2. Update the hash code in the macro to the new value.

3. Rerun the macro processing.

[NOTE]
====
The error message contains the 64 character hex code as eight times eight characters dot-separated.
It helps you select a part of the code when you copy the new code into the documentation after the update.
It also helps you select different parts if you want to have more than one reference to the hash code.
The dots are not part of the code and are printed only for convenience and ignored when comparing.
You can use as many or as few dots in the hash code as you like.

The hash code is displayed using  lower case hexadecimal characters, but you can use upper case or mixed case characters.
Before the check, the dots are removed, and the characters are converted to a lower case.
====

In some rare cases, you do not want to check all the modifications of the file.
You specify the option `lines` to check the number of lines in the snippet or file has not changed.
To do that, you can

[source,text]
----
{@snip:check lines=22 id=snippet1,snippet2}
----

and the macro will not error so long as long the snippet or the file contains exactly 22 lines.

You can specify both the `lines` and the `hash` together, but it does not make much sense.
The macro will check the hash value first.
If the hash value fails, the macro results an error.
If the hash value is correct, the file or snippet is identical, meaning it has the same number of lines as before.

{%#define JAMAL_SNIPPET_CHECK={%@snip SnipCheck_JAMAL_SNIPPET_CHECK /"(.+)"/%}%}
You can ask the macro `snip:check` to ignore its task defining the `{%JAMAL_SNIPPET_CHECK%}` system property to `false`.
It is handy when your documentation has many `snip:check` control, and the compilation of the documentation is don in the tests.
This would require the update of the hash code in the documentation whenever you make any small changes in the source code.
To avoid this you can

[source]
----
mvn clean verify -D{%JAMAL_SNIPPET_CHECK%}=false
----

which will compile your code on the development machine fine.
When you are finished with the adhoc changing, however, you have to update the documentation to reflect the changes in the code.

There is another way to force processing without error.
The macro `snip:check` has the option `snipCheckWarningOnly` (aliased as `warning`, `warningOnly`).
The name `snipCheckWarningOnly` is supposed to be used globally in the Jamal file via the `options` macro.
On the macro you will probably use `warning` or the more expressive `warningOnly`.
With this option the macro will not cause bad syntax error in case the check fails.
It will only log into the log file a warning message.

NOTE: Even when you use the `snipCheckWarningOnly` option, the macro will cause bad syntax when the hash code is too short, or there are some other errors.
It is only to supress hash code or line mismatch.

Using the option `warning` the error message will be sent to the log as a warning.
If you use the option `snipCheckError` (aliased as `error`) then the error message will be sent to the log as an error.
In this case, the error will not be suppressed.
You cannot use `warning` and `error` together.

[[snipList]]
=== {%chapter%}`snip:list`
{%#snip:check file={%JAVA_DIR%}SnipList.java hash=c7f80976%}
This macro lists the defined snippets.
{%parameterized%}

The list is represented as comma-delimited, which contains the names of the snippets.

There are four parameters the macro handles; all are optional:

* `name` {%alias id%} for the name of the snippet

* `file` {%alias fileName%} for the file name of the snippet

* `text` {%alias contains%} for the content of the snippet

* `listSeparator` can redefine the list separator. The default is the comma.

The first three parameters are interpreted as regular expressions.
If any missing or empty string, then the parameter is not taken into account.
If any of them is specified, only those snippets will be listed that match the expression.

The listing will filter the snippets to include only those into the list that

* the name of the snippet matches the parameter `name`, and

* the file name from which we harvested the snippet matches the parameter `file`, and

* at least one line of the snippet matches the parameter `text`.

The matching means that the regular expression should match part of the text.
If you want to match the full name, file name, or content line, you have to use a `^ ... $` format regular expression.

If all the parameters are missing, then the macro will list all the snippet names.

NOTE: The versions 2.2.0 and later do not include the snippets in the list which are errored.
These are snippets, which are not closed.
These are usually not snippets, but their start is recognized as a snippet start.
You can have the word `snippet` in your code followed by something that may look like a snippet start.
This is not an error in Jamal, only if you try to use any of these snippets.

[[snipSave]]
=== {%chapter%}`snip:save`
{%#snip:check file={%JAVA_DIR%}SnipSave.java hash=f5cec793%}
This macro saves all the collected snippets to a file.
{%parameterized%}
The file name must be specified by the parameter `output`.
The general syntax of the macro is

[source,text]
----
{@snip:save options}
----

The usable options are the following:
{%@define REGEXTO=regular expression to match%}
* `name` {%alias id%} {%REGEXTO%} the name of the snippet

* `file` {%alias fileName%} {%REGEXTO%} the file name of the snippet

* `text` {%alias contains%} {%REGEXTO%} the content of the snippet

These parameters are interpreted as regular expressions.
If there is any missing or empty string, the parameter is not considered.
If any of them is specified, the macro will save only those snippets that match the expression.

* `output` should specify the name of the output file.
It is a mandatory parameter.

* `format` can specify the format of the output file.
The default value is `XML`.
The available formats are `XML` and nothing else.
This parameter is present for future compatibility and to provide readability if the command has to specify that the output is XML.

* `tab` {%alias tabSize%} can specify the number of spaces to use for indentation.
The default value is 4.
{%!@for $X in (NS,SNIPPETS,SNIPPET,TIME_STAMP,DATE_TIME,ID,FILE,LINE,COLUMN,HASH)=
{%#define saveLoad:$X={%@java:field (format=`$value`) javax0.jamal.snippet.SnipSave#$X%}%}%}

The saved XML file will use the namespace {%saveLoad:NS%}.
The top level element is {%saveLoad:SNIPPETS%}.

The {%saveLoad:SNIPPETS%} tag has the following attributes:

* {%saveLoad:TIME_STAMP%} is the time stamp {%@define WHEN=when the snippets were saved.%}{%WHEN%}

* {%saveLoad:DATE_TIME%} the date and time {%WHEN%}

The timestamp and the date/time values reflect the same value.
Programs reading the XML can use the timestamp value.
The human-readable date-time value is for the human reader.
Currently, none of these values are used by Jamal.

The elements below the {%saveLoad:SNIPPETS%} tag are {%saveLoad:SNIPPET%} tags.
Every {%saveLoad:SNIPPET%} tag has the following attributes:

* {%saveLoad:ID%} id the identifier of the snippet.
When this XML is loaded, <<snipLoad,`snip:load`>> will use this identifier to load the snippet.

* {%saveLoad:FILE%} the file the snippet was defined in.
When this XML has loaded, this file name will be restored so that the snippet will look like one loaded from this file.

* {%saveLoad:LINE%} is the line number in the file where the snippet starts.
When this XML is loaded, this line number will be restored so that the snippet will look like one loaded from this line from the specified file.

* {%saveLoad:COLUMN%} is the column where Jamal initially loaded the snippet from.
This value is usually `1` since snippets are multi-lined strings and do not contain fractional lines.
The snippet will look like one loaded from this column from the specified line when this XML is loaded.

* {%saveLoad:HASH%} contains the hash value of the snippet.
This value is calculated precisely as the hash value in the <<snip_check,`snip:check`>> macro.
When the <<snipLoad,`snip:load`>> macro reads the XML file, it compares the hash value calculated from the snippet's text with the hash value.
It is an error if the hash values do not match.
In that case, the snippet loading terminates, and no more snippets are loaded from the XML file.
The snippets already loaded will stay put.
Note, however, that you are allowed to delete the hash attribute from the XML file using an editor of your choice.
In that case, no check is performed.

The text of the snippet is the content of the {%saveLoad:SNIPPET%} tag.
It is saved as a `CDATA` section(s).

[[snipLoad]]
=== {%chapter%}`snip:load`
{%#snip:check file={%JAVA_DIR%}SnipLoad.java hash=bb0fe0aa%}
This macro can load the snippets from a file, which was saved by <<snipSave,`snip:save`>>.
{%parameterized%}
The file's name has to be specified by the parameter `input`.
The general syntax of the macro is

[source,text]
----
{@snip:load options}
----

The usable options are the following:

* `name` {%alias id%} {%REGEXTO%} the name of the snippet

* `file` {%alias fileName%} {%REGEXTO%} the file name of the snippet

* `text` {%alias contains%} {%REGEXTO%} the content of the snippet

These parameters are interpreted as regular expressions.
If there is any missing or empty string, the parameter is not considered.
If any of them is specified, the macro will load only those snippets that match the expression.

* `input` should specify the name of the input file.
It is a mandatory parameter.

* `format` can specify the format of the input file.
The default value is `XML`.
The available formats are `XML` and nothing else.
This parameter is present for future compatibility and to provide readability if the command has to specify that the input is XML formatted.

The XML file format has to be the same as the one used by the <<snipSave,`snip:save`>> macro.
It has to use the same namespace and tags.
The content of snippets must be in a CDATA section(s).

The {%saveLoad:TIME_STAMP%}, and {%saveLoad:DATE_TIME%} attributes of the tag {%saveLoad:SNIPPETS%} may be missing and are ignored during reading.
The attributes of the {%saveLoad:SNIPPET%} tags are mandatory except the {%saveLoad:HASH%} attribute.
If the {%saveLoad:HASH%} attribute is present, the macro will check its value against the content of the snippet.
It guarantees the snippet integrity.
If the tag is missing, the check is skipped.

Any tag can have any extra attributes.
Extra attributes are ignored.
If you want to change something in the XML file and edit some snippet code temporarily, you can rename the tag {%saveLoad:HASH%} to `_hash`, for example.

[[trimLines]]
=== {%chapter%}`trimLines`, `trim`
{%#snip:check file={%JAVA_DIR%}TrimLines.java hash=4ff61307%}
This macro can cut off the unneeded spaces from the start and end of the lines.
{%parameterized%}

When you include a code fragment in the documentation as a snippet, the lines may have extra spaces at the start.
It is the case when the fragment comes from a code part somewhere in the middle of a tabulated structure.
This macro can remove the extra spaces from the start of the line keeping the relative tabulation of the lines.
The code formatting remains the same as the source code, but the macro will align the code sample to the left.

The syntax of the macro is:

[source]
----
{@trimLines ...

  possible
    multiple lines
}
----

For example:

{%untrimmedSample/
{@trimLines
  k
   a
   b
 c
}
%}

will result

{%untrimmedOutput%}

The lines to be trimmed should start on the line following the name of the macro.
The characters following the macro name to the end of the line are parsed for options.
Options currently are:

* `margin` can specify the minimum number of spaces that appear in front of every line.
You can even insert extra spaces in front of the lines while keeping the tabulation using this option.

* `trimVertical` is a boolean parameter to remove the new line character from the sample's start and end.
It eliminates the leading and trailing empty lines.

* `verticalTrimOnly` {%alias vtrimOnly%} instructs the macro to do only the vertical trimming.
If this option is defined, there is no need to define `trimVertical` also.

The macro can also delete the empty lines from the start and the end of its input if the option `trimVertical` is set.
For example

{%untrimmedSample/
{#trimLines
{@options trimVertical}



  k
   a
   b
  c


}
%}

will result

{%untrimmedOutput%}

[[untab]]
=== {%chapter%}`untab`
{%#snip:check file={%JAVA_DIR%}Untab.java hash=3c83075b%}

The syntax of the macro is:

{%sample/
{@untab tabSize=8
multiple line of
    text with \t tab characters
}
%}

This macro replaces the tab characters in the input with spaces.
Each tab will be replaced with one or more spaces so that the alignment of the lines is preserved.
The tab stop is 8 by default, but it can be set to any value using the options `tabSize`.
This option has two aliases `tab` and `size`, which you can also use as macro parameters.
However, only `tabSize` is recognized as a macro if defined outside or inside the `untab`.
With that you can set the tab stop globally for all the snippets:

{%sample/

{@define :tabSize=8}
...

{@untab ... tabSize is defined as a global macro

  possible
    multiple lines
}
%}

{%@comment we need to have a separate file edited using VI or some other tab-friendly editor%}
For example:
{%@snip:check id=untabSample,untabSampleOutput hash=3ea1ff00 message="Check the untab sample if it is still okay!"%}
[source,text]
----
{%@define TRANSFORMATIONS=actions=replace,trim replace="/\"//" replace=/\\n// replace=/\+//%}
{%#snip ({%TRANSFORMATIONS%}) untabSample%}
----

will be converted to

[source,text]
----
{%#snip ({%TRANSFORMATIONS%}) untabSampleOutput%}
----


[[range]]
=== {%chapter%}`range`
{%#snip:check file={%JAVA_DIR%}RangeMacro.java hash=8aa2bd10%}

This macro can filter lines of its input by a range of numbers.
The syntax of the macro is:

{%sample/
{@range lines=1..3,5..7;..1,0

lines
}
%}

The macro has an alias `ranges` that you are free to use in case the plural form is more readable.
The option `lines` cannot be used in singular, but it can also be aliased as `range` or `ranges`.

The format and the meaning of the option `lines` is exactly the same as the option of the same name in the core `import` macro.

{%TEXT:RANGE%}

[[Base64]]
=== {%chapter%}`base64` encode and decode
{%#snip:check file={%JAVA_DIR%}Base64.java hash=01b6f7bc%}

There are two macros that can encode and decode the input using the Base64 algorithm.
The encoding macro is called `base64`.
It also has an alias `base64:encode`.

The decoding macro is named `base64:decode`.

By default, the macros trim the input removing the spaces from the start and from the end.
If you need to encode a string that contains spaces you can use the option `quote`.
In this case, the string has to be quoted.
Any character can be used as quoting character except space and the same character should be used at the start and at the end of the string.
The option `quote` can be used with the decoding macro as well to provide coherent use, although there is not much use of the option in this case.


{%sample/
{@base64:encode This is a test}
%}

will result in

{%output%}

and

{%sample/
{@base64:decode VGhpcyBpcyBhIHRlc3Q=}
%}

will result in

{%output%}

If you need a space before the text also encoded you should write

{%sample/
{@base64:encode (quote) " This is a test"}
%}

resulting in

{%output%}

and again the reverse:

{%sample/
>>{@base64:decode (quote) "IFRoaXMgaXMgYSB0ZXN0"}<<
%}

will result in

{%output%}

As the `>>` shows that the space is also decoded.

Both then encoding and the decoding macro can have the option `url`.
In this case, URL safe encoding is used.
The encoding macro will also handle the option `compress`.
Using this option, the string is first compressed before encoding.

NOTE: There is no option to decode the compressed string.
This option was developed to support link:https://docs.kroki.io[Kroki] service GET requests.

With these options, you can encode the following string:

{%@define KROKI_SAMPLE=
image::https://kroki.io/plantuml/svg/{@base64 (compress url)
skinparam ranksep 20
skinparam dpi 125
skinparam packageTitleAlignment left

rectangle "Main" {
(main.view)
(singleton)
}
rectangle "Base" {
(base.component)
(component)
(model)
}
rectangle "<b>main.ts</b>" as main_ts

(component) ..> (base.component)
main_ts ==> (main.view)
(main.view) --> (component)
(main.view) ...> (singleton)
(singleton) ---> (model)
}[]
%}

{%sample/{%KROKI_SAMPLE%}%}

which will result in

{%output%}

{%#killLines pattern="source|----"
{%output%}%}

[[repeat]]
=== {%chapter%}`repeat`

{%@snip Repeat_documentation%}

[[rot13]]
=== {%chapter%}`rot13`
{%#snip:check file={%JAVA_DIR%}Rot13.java hash=2346fc70%}

This macro calculates the ROT13 transformation of the input.
For example

{%sample/
{@rot13 ROT13 is a simple letter substitution cipher
that replaces a letter with the 13th letter after it in the alphabet.
ROT13 is a special case of the Caesar cipher which
was developed in ancient Rome.}
%}

will result in

{%output%}

Rot13 encoding is not a strong encryption algorithm.
It can easily decrypt by the reader visiting the site http://rot13.com/
The main use is to provide some kind of obfuscation for the text that requires some effort to decipher.
For example, your document asks a question to the reader, and you also give the answer in ROT13.
The reader will not be able to read the answer, only when they put effort deciphering.

I usually use this macro to write a __"Do not edit this file, it is generated"__ already rot13 encoded in the `.jam` file.
This way the source file you edit will contain an unreadable rot13 encoded text, but the generated file contains the readable warning.

[[def]]
=== {%chapter%}`def`


The macro `def` is a simple convenience macro that defines a user defined macro.
The syntax of the macro is simplified:

{%sample/
{@def name=value}
{name}
%}

and it will result

{%output%}

NOTE: The value appears twice.
The macro `@def` also returns the value.

This macro can be used when there is a repeated text in the document.
You can use this macro at the text's first occurrence, and use the macro in consequent places.
It is a convenience macro, which gives a name to a text.

In principle, you can get the same result using the core `define` macro.
The differences are:

* The `def` macro is shorter to write.
* The `def` macro returns the value, there is no need to use the macro immediately after the definition.
* The `def` macro does not have parameter `options`, and as such
** it cannot throw an error or skip the definition if the macro is already defined, it will redefine the macro, and
** it cannot define a macro to be pure, verbatim etc.
* The `def` macro does not have parameters, thus the value is always a plain text.
* You cannot define global macros using `def` and therefore the name must not contain the `:` character.



[[urlencode]]
=== {%chapter%}`urlencode`

This macro will URL encode its input.
The format of the macro is

{%sample/
    http://my.precious.com/what?{@urlencode (charset=UTF-8) query=" this is a quoted string"}
%}

which, in this example will result

{%output%}

The macro has one option parameter:

* `charset` (alias `cs`) - the character set to use for encoding. The default is `UTF-8`.


[[pos]]
=== {%chapter%}`pos`
{%#snip:check file={%JAVA_DIR%}Pos.java hash=f8a8cd1d%}

This macro will result the

* file name,
* line number, or
* column number

of the actual location.
The simple way of using the macro is, for example

{%sample/
{@pos.file}:{@pos.line}:{@pos.column}
%}

will result

{%output%}

The version introduced after 1.12.4 also handles options between `(` and `)`:

{%#eval {%`@comment%}
{%#replaceLines replace="~.*?final\\s+var\\s+\\w+\\s*=\\s*scanner\\..*?\\(null,(.*?)\\).*~* $1~.*//\\s*~" replace="~\"(\\w)~`$1~(\\w)\"~$1`~"
{%@snip pos_options%}
%}%}

The actual file name and line number may not be the one where the macro is in the file.
It is where the macro `pos` is evaluated.
This behaviour may result that the line number or column is not accurate when the macro is not evaluated from the top level context.
It is also known that Jamal increases the line numbers in some cases extensively during maco evaluation.
This is a known bug resulting in the line number larger than the actual.

[[sort]]
=== {%chapter%}`sort`
{%#snip:check file={%JAVA_DIR%}Sort.java hash=7588aafa%}
This macro returns the input sorted.
The default behaviour is to sort the lines of the input alphabetically.
For example

{%sample/
{@sort
beta
zeta
alpha}
%}

will result the output

{%output%}

To have more flexibility you can use parameters on the first line of the input to specify collating order, record separator and so on.

The options are:

{%#replaceLines replace="/^.*scanner\\..*?\\(.*?\"(.*?)\"\\).*$/* `$1`/" \
replace="/\",\\s*\"/`, alias `/" replace="~//~~"
{%@snip sort_options%}%}

The input is treated as a list of textual records separated by strings.
The separator can be defined as a regular expression.
The default value is `\n`, which means that the individual lines will be the records.
An example, different from the default record separator:

{%sample/
{@sort separator=### join=### pattern="key=(.*)" numeric
key=1
this
is one record
###
key=03
This is the second
record, multiple lines
###
key=2
This gets into the middle
}
%}

will result

{%output%}

This sample uses a pattern to select the key, a non-default joining string, and it also specifies that the sorting has to be numeric.

The next example specifies the sorting when the collating order is specified.
Here the collating order is Hungarian.
{%sample/
{@sort locale=HU
Cukor
Csiga
Császár
Czucor
Abrak
}
%}

It will result the following order:

{%output%}

Note that the special character `á` is properly used as it follows the letter `a` in the Hungarian collation order.
Also, the `cs` is a compound sound following the letter `c` in Hungarian and that way `Czucor` comes before `Császár` or `Csiga`, whatever they mean.


The next example uses semantic versioning.

{%sample/
{@sort collator=semver
1.0.0-alpha
1.0.0-alpha.beta
1.0.0-beta
1.0.0-beta.2
1.0.0-alpha.1
1.0.0-beta.11
1.0.0-rc.1
1.0.0
}%}

It will result the following ordering:

{%output%}

NOTE: The sample above does not specify the fully qualified class name of the collator.
The macro `sort` implements a little shortcut for the semantic versioning collator provided in the Jamal source code.
If you write `semver` (case insensitive) instead of the fully qualified domain name, it will automatically use the `javax0.jamal.snippet.SemVerCollator` class as collator.

[[numberLines]]
=== {%chapter%}`numberLines`
{%#snip:check file={%JAVA_DIR%}NumberLines.java hash=db75d8d3%}
This macro can put numbers in front of the lines, sequentially numbering them.
{%parameterized%}

The syntax of the macro is

[source]
----
{@numberLines options
     ..
     ..
     ..
}
----

By default, the numbering of the lines starts with one, and every line gets the next number.
For example

{%sample/
{@numberLines
this is the first line
this is the second line
this is the third line
}
%}

will result
{%#snip:define numberedLines1={%output%}%}\

{%@snip numberedLines1
[source]
----
1. this is the first line
2. this is the second line
3. this is the third line
----
%}

The macro will insert the number with a `.` (dot) after the number and space.

The parameters `start`, `step`, and `format` can define different start values, step values, and formats for the numbers.
For example

{%sample/
{#numberLines start=3 step=2 format=" %03d::"
this is the first line
this is the second line
this is the third line
}
%}

will result
{%#snip:define numberedLines2={%output%}%}\

{%@snip numberedLines2
[source]
----
003::this is the first line
005::this is the second line
007::this is the third line
----
%}

The standard Java method `String::format` will format the number using the formatting string.
Any illegal formatting will result in an error.

[[killLines]]
=== {%chapter%}`killLines`
{%#snip:check file={%JAVA_DIR%}KillLines.java hash=424c8b47%}
This macro deletes, or keeps the selected lines from its input.
{%parameterized%}

The format of the macro is

[source]
----
{@killLines parameters

 ...

}
----

or

[source]
----
{@filterLines parameters

 ...

}
----

NOTE: We recommend using the `filterLines` and `pattern` aliases when you want to keep the lines matching the pattern and delete the other lines. In other cases the `filterLines` and `kill` or `killLines` and `kill` or `pattern` aliases can be used. The `killLines` and `keep` aliases together are not recommended.

The default behavior of the macro is to delete the empty lines.
In that case, it removes all lines that contain only spaces or nothing at all.

The parameter macro `pattern` may define a regular expression to select the lines.

For example:

{%sample/
{#killLines pattern=^\s*//
/* this stays */
// this is some C code that we want to list without the
// single line comments

#define VERSION 1.0 //this line also stays put
int j = 15;
}
%}

creates the output

{%output%}

If the option `keep` is used then the lines that match the pattern are kept and the other lines are deleted.


{%sample/
{#killLines pattern=^\s*// keep
/* this stays */
// this is some C code that we want to list without the
// single line comments

#define VERSION 1.0 //this line also stays put
int j = 15;
}
%}

creates the output

{%output%}

In this case only the comment lines remained that start with `//` at the start of the line.

[[skipLines]]
=== {%chapter%}`skipLines`
{%#snip:check file={%JAVA_DIR%}SkipLines.java hash=5015f291%}
You can use this macro to skip lines from the snippet.
{%parameterized%}

It is similar to <<killLines,`killLines`>> but this macro deletes ranges of lines instead of individual lines.
The macro uses two regular expressions, named `skip` and `endSkip`.
When a line matches the line `skip`, the line and the following lines are deleted from the output until a matching `endSkip`.
The macro also deletes the lines that match the regular expressions.

For example,

{%sample/
{@skipLines
this line is there
skip this line and all other lines until a line contains 'end skip' <- this one does not count
this line is skipped
this line is skipped again
there can be anything before 'end     skip' as the regular expression uses find() and not match()
there can be more lines
}
%}

will result
{%#snip:define skipLines1={%output%}%}\

{%@snip skipLines1
[source]
----
this line is there
there can be more lines
----
%}

You can also define the regular expressions defining the parameters `skip` and `endSkip`.
For example,

{%sample/
{#skipLines {@define skip=jump\s+starts?\s+here}{@define endSkip=land\s+here}
this line is there
jump start here
this line is skipped
this line is skipped again
land                 here
there can be more lines
}%}

will result
{%#snip:define skipLines2={%output%}%}\

{%@snip skipLines2
[source]
----
this line is there
there can be more lines
----
%}

It is not an error if there is no line matching the `endSkip`.
In that case, the macro will remove all lines starting with a string matching the `skip` from the output.
There can be multiple `skip` and `endSkip` lines.
The `skip` and `endSkip` lines cannot be nested.
When there is a match for a `skip`, any further `skip` is ignored until an `endSkip`.

[[replace]]
=== {%chapter%}`replace`
{%#snip:check file={%JAVA_DIR%}Replace.java hash=a41a3951%}
The macro `replace` replaces strings with other strings in its input.
{%standardInput%}

It uses the first argument as the input, and then every following argument pairs as search and replace strings.
For example:

{%sample/
{@replace /the apple has fallen off the tree/apple/pear/tree/bush}
%}

will result:
{%#snip:define replace1={%output%}%}\

{%@snip replace1
[source]
----
the pear has fallen off the bush
----
%}

If the parop `regex` is true, then the search string is treated as regular expressions, and the replace string may also contain replacement parts.
For example,

{%sample/
{#replace {@options regex}/the apple has fallen off the tree/appl(.)/p$1ar/tree/bush}
%}

will result in the same output
{%#snip:define replace2={%output%}%}\

{%@snip replace2
[source]
----
the pear has fallen off the bush
----
%}
but this time, the replace used regular expression substitution.

The macro also supports the parop `detectNoChange` to error when some of the search strings are not found in the input.
This parop can also be defined as an option.
In that case you can switch it off using the option `(detectNoChange=false)` in the macro.


[[replaceLines]]
=== {%chapter%}`replaceLines`
{%#snip:check file={%JAVA_DIR%}ReplaceLines.java hash=042e57ce%}
This macro replaces strings in the input.
{%parameterized%}

It works similarly to the macro <<replace,`replace`>>.
The difference is that the `replaceLine`

* always works with regular expressions, and

* it works on the individual lines of the input in a loop.

The difference is significant when you want to match something line by line at the start or the end of the line.
For example,

{%sample/
{@define replace=/^\s*\*\s+//}
{@replaceLines
* this can be a snippet content
* which was collected
* from a Java or C program comment
}
%}

will result
{%#snip:define replaceLines1={%output%}%}\

{%@snip replaceLines1
[source]
----
* this can be a snippet content
* which was collected
* from a Java or C program comment
----
%}

The searched regular expressions and the replacement strings have to be defined in the parameter `replace`.
This parameter can be defined inside the `replaceLines` macro.
The macro scans the value of the parameter `replace` using the {%ARGSPLIT%}.

It is usually an error when no lines are replaced in a snippet.
Use the parameter`detectNoChange` to detect this.
If this boolean parameter is `true`, the macro will error if it changes no line.

[[counter_define]]
=== {%chapter%}`counter:define`
{%#snip:check file={%JAVA_DIR%}CounterMacro.java,src/main/java/javax0/jamal/snippet/Counter.java hash=f645b1c0%}
This macro defines a counter.
The counter can be used like a parameterless user-defined macro that returns the actual formatted value of the counter each time.
The actual value of the counter is modified after each use.
The format of the macro is

[source]
----
{@counter:define id=identifier}
----

==== Flat Counter

In this section, we will discuss the simpler form of the counter.
This counter is a simple integer counter that is increased each time it is used.
The hierarchical counter introduced in the release {%RELEASE:IZMIR%} is discussed in the next section.

The value of the counter starts with 1 by default and is increased by 1 each time the macro is used.
For example,

{%sample/
{@counter:define id=c} {c} {c} {c}
%}

will result

{%output%}

You can define the `start`, and the `step` value for the counter as well as the `format`.
For example,

{%sample/
{#counter:define id=c start=2 step=17} {c} {c} {c}
%}

will result

{%output%}

The format can contain the usual `String.format` format string.
In addition to that, it can also contain one of the `$latin`, `$LATIN`, `$greek`, `$GREEK`, `$cyrillic`, `$CYRILLIC`, `$roman`, `$ROMAN` literals.

NOTE: You can also use the `$alpha`, `$ALPHA` placeholders instead of `$latin`, `$LATIN`.
This is provided for backward compatibility with versions where the Greek and Cyrillic alphabets were not available.

{%@define alphaRomanReplace($format,)={%@ident%}\
{%@counter:define id=sample_counter format=$format%}\
* `$format` will be replaced by `{%sample_counter%}, {%sample_counter%}, {%sample_counter%} . . .` for `1, 2, . . .` %}\
{%alphaRomanReplace/$alpha%}
{%alphaRomanReplace/$ALPHA%}
{%alphaRomanReplace/$greek%}
{%alphaRomanReplace/$GREEK%}
{%alphaRomanReplace/$cyrillic%}
{%alphaRomanReplace/$CYRILLIC%}
{%alphaRomanReplace/$roman%}
{%alphaRomanReplace/$ROMAN%} counter values.

It is an error
{%@define errorMessage($format,$number)={%@ident%}\
* if either `$format` or `{%@case:upper $format%}` is used in the format, and the value is zero, negative, or larger than $number%}
{%errorMessage /$alpha/26%},
{%errorMessage /$greek/24%},
{%errorMessage /$cyrillic/32%}, or
{%errorMessage /$roman/3999%}.

In some applications the number 4 is depicted as `IIII` instead of `IV` when using roman numerals.
You can see such use typically on some clock faces.
If you want to use this notation you can use the option `IIII` (all capital).
The use of this option makes only sense when you also specify the `$roman` or `$ROMAN` in the format.
The macro does not check this.

Examples:

{%sample/
{@counter:define id=h format=$roman IIII}{h} {h} {h} {h} {h} {h} {h} {h} {h} {h} {h}
%}

will result in

{%output%}


{%sample/
{#counter:define id=cFormatted{@define format=%03d.}}{cFormatted} {cFormatted} {cFormatted}
{#counter:define id=aFormatted{@define format=$alpha.}}{aFormatted} {aFormatted} {aFormatted}
{#counter:define id=AFormatted{@define format=$ALPHA.}}{AFormatted} {AFormatted} {AFormatted}
{#counter:define id=rFormatted{@define format=$ROMAN.}{@define start=3213}}{rFormatted} {rFormatted} {rFormatted}
{#counter:define id=RFormatted{@define format=$ROMAN.}{@define start=3213}}{RFormatted} {RFormatted} {RFormatted}
%}

The output will be

{%#snip:define counter3=
{%output%}%}\

{%@snip counter3
[source]
----
001. 002. 003.
a. b. c.
A. B. C.
MMMCCXIII. MMMCCXIV. MMMCCXV.
MMMCCXIII. MMMCCXIV. MMMCCXV.
----
%}

Sometimes you want to use the current value of the counter multiple times.
It is possible to define a macro using the counter and then use the macro referring to the value.
For example, the following code

{%sample/
{@counter:define id=c}{c} {#define second={c}}{second} {second} {c}
%}

will result

{%output%}

The implemented counters provide a simplified approach for this.

{%sample/
{@counter:define id=c}{c} {c} {c last} {c}
%}

will have the same output:

{%output%}

In this case we used the word `last` as an argument to the counter macro `c`, which instructs the macro to return the last value without an increment.

Sometimes you want to refer to the value of the counter much later when the counter was already increased multiple times.
In that case you can still use the `define` as used above, but the macro counter also gives a shortcut to do that.
If you write

{%sample/
{@counter:define id=m}{m} {m -> secondChapter} {m} {m} is still {secondChapter}
%}

will result

{%output%}

The user defined macro `m`, which is a counter interprets the argument and create a new user defined macro named `secondChapter`.
The value of this user defined macro will be the same as the actual value of the counter.

[NOTE]
====
The `-` character before the `>` is a macro parameter separator, and the macro itself checks only the `>` character.
It means that you can use `.>`, `+>` or `/>` or any other non-alphanumeric first character in front of the `>`.
It is recommended to use the `-` or `=` for readability reasons.
====

==== Hierarchical counter

A hierarchical counter counts numbers in a hierarchical way.
This is the usual way to number chapters and sections in a document.
The advantage of this counter over using the built-in formatting of the markup you use is that you can have several independent counters in the same document.

To define a hierarchical counter you use the same `counter:define` macro with the key `hierarchical`.

{%sample/
{@counter:define id=h hierarchical}
%}

The use of the counter is the similar to the flat counter.
You simply have to use the name of the counter like a build in macro.

{%#comment {%output%}%}{%sample/
{h} {h} {h} {h}
%}

resulting in:

{%output%}

The hierarchical nature comes to life when you `open` and `close` a hierarchy level.
Opening a new level is done simply writing the word `open` as an argument to the counter macro.
Similarly, closing a level is done by writing the word `close`.

Continuing the previous example:

{%sample/
{h open} {h} {h open} {h} {h open} {h} {h close} {h} {h close} {h} {h close} {h}
%}

will result in:

{%output%}

Opening and closing are not the only difference and possibility of the hierarchical counter.
A hierarchical counter can have a different format for each level in a single format string.
The format string can contain all the formatting elements that the flat counter can use.
However, in addition to that, it can also contain parts between `{` and `}`.

The syntax of these parts is `{<level>:<format>}`.
The `<level>` is a number starting with 1.
When the actual level of the counter is smaller than the `<level>` the format is ignored.
When the actual level is equal or larger than the `<level>` the format is used.
The `<format>` is the format string that is used for the counter.
The format can also contain the placeholder `$title` or `$TITLE` that will be replaced by the title of the level as defined in the argument `title` (see later).


The format can be defined using the macro `define`, inherited from the `counter:define` or as an argument to the counter macro in this order.
When using the macro `define` the name of the user defined macro is the name of the counter and appending `$format` to it.

To demonstrate all these possibilities, we use the following example:

{%sample/
{@counter:define id=k hierarchical format="%d{2:.$greek}{3:.$roman}"}\
format inherited: {k}{k open}
format inherited: {k}{k open}
format inherited: {k}
format inherited: {k}
format defined as parameter: {k format="%d{@ident {2:.%02d}{3:.%03d}} $title" title="This is the title"}
format defined in k$format: {@define [verbatim]k$format=$ROMAN{2:.$roman}{3:.$roman}}{k}
%}

which will result in:

{%output%}

NOTE: When the format string is defined as a user defined macro, it is better a `verbatim` macro to avoid the macro interpretation of the parts between the `{` and `}` characters.
When the macro start and stop strings are not `{` and `}` it is not so crucial.

The hierarchical counter can also have a title.
The title is defined using the parameter `title` and can be used in the format string using the placeholder `$title` or `$TITLE`.

Similarly to flat counter, you can also refer to the last value of the counter using the argument `last`.

{%sample/
{k last}
%}

will result in:

{%output%}

You may want to refer to a counter value other than the last one.
In this case, you can use a `define` macro to store the formatted value of the counter, or you can "save" the counter.
Using the parameter `save` (also aliased as `saveAs`) with a string argument you clone a frozen version of the counter.
For example:

{%sample/
{k save=z} {z} {z format="%d.{@ident {2:%d}.{3:%d}}"}
%}

will result in:

{%output%}

The frozen version will retain its value and will not be incremented.
On the other hand, it can be formatted.

NOTE: Counters flat or hierarchical are technically user defined macros, but they will not be saved or loaded by the macro `references`.
If you need a forward reference to a counter, you should define a user defined macro via the macro `define` and use that to reference the counter.

{%CH /references/references%}

[[reflow]]
=== {%chapter%}`reflow`
{%#snip:check file={%JAVA_DIR%}Reflow.java hash=151bbf6c%}
This macro reflows the content.
{%parameterized%}

The default behavior is to remove all single new-line characters replacing them with spaces.
That way, the lines will extend without wrapping around, and double newlines will separate the paragraphs.

For example:

{%sample/
{@reflow
The
short
lines
will
be put into a single line.

Empty lines are paragraph limiters.




Multiple empty lines are
converted to one.}
%}

The output will be

{%output%}

If the parameter `width` specifies a positive integer number, the macro will use it to limit the length of the lines.
For example

{%@define reflowSample=0123456789|
The
long
lines
will
be broken into words.

Empty lines are paragraph limiters.%}

{%@define REFLOW_WIDTH=10%}
{%sample/
{@reflow width={%REFLOW_WIDTH%}
{%reflowSample%}
}
%}

The output will be

{%output%}

The lines are collected and broken so that none of the lines is longer than {%REFLOW_WIDTH%}.
In some cases, limiting is not possible.
When the width is too small but still positive, some words may be longer than the given width.

{%@define REFLOW_WIDTH=1%}\
For example, setting the width to `{%REFLOW_WIDTH%}`, reflow will cut the lines into words, but it will not break the individual words.

{%sample/
{@reflow width={%REFLOW_WIDTH%}
{%reflowSample%}
}
%}

The output will be

{%output%}


The `width` parameter can be a macro option as well as a macro.
For example

{%sample/
{#reflow {@define width={%REFLOW_WIDTH%}}
{%reflowSample%}
}
%}

will have the same result as:

{%output%}

Setting the `width` to any non-positive value will remove the limit from the line length.
You may use this to override a globally set `width` macro.

[[snipLine]]
=== {%chapter%}`snip:line`

The macro `snip:line` results in the starting line number of the snippet in the file where the snippet is defined.
For example, if the snippet `hubbaba` was collected from a file with the `snippet hubbaba` on line 5, the macro will return 6.
The returned number counts the lines at the start of the file with one, and it is the line, which is the first line of the snippet following the snippet signaling line.

In this document, we use different snippets collected from the Java files of the snippet library.
One of the snippets is named `collect_options`.
It contains the lines that list the options for implementing the macro `snip:collect`.

The snippet `collect_options` is defined in the file {%#file (format=`$simpleName`) {%@snip:file collect_options%}%} at the line {%@snip:line collect_options%}.

You can find the previous sentence in the {%@file (format=`$simpleName`) README.adoc.jam%} file as:
{%sample/
{%@escape* ``The snippet `collect_options` is defined
in the file {%#file (format=`$simpleName`) {%@snip:file collect_options%}%}
at the line {%@snip:line collect_options%}.``%}
%}

You can use this macro to refer to a source code line or if you want to include some source code into your documentation with the actual positions as line numbering.
The syntax of the macro is

{%sample/
{@snip:line snippet_name}
%}

{%@define SNIPLINE_NOCOMMENT=The text following the snippet id is ignored, reserved for future development.%}
{%SNIPLINE_NOCOMMENT%}

[[snipFile]]
=== {%chapter%}`snip:file`

The macro `snip:file` returns the file's name where the snippet is defined.
The returned file name is a full absolute path.
If you want to display only the name or the directory, you can use the macro <<file,`file`>> to format the output.
It is recommended to use this macro together with the macro <<snipLine,`snip:line`>> described above.

You can use this macro to refer to a source file.
The syntax of the macro is

{%sample/
{@snip:file snippet_name}
%}

{%SNIPLINE_NOCOMMENT%}

[[snipEval]]
=== {%chapter%}`snip:eval`
{%#snip:check file={%JAVA_DIR%}Eval.java hash=20a638e1%}

This macro will evaluate the content of a snippet as Jamal macro.
The functionality is very close to the core macro `eval` but

* it evaluates ONLY using Jamal
* takes into account the position of the snippet.

When a snippet is evaluated using the core `eval` macro the text of the snippet is evaluated.
It means that the evaluation has no idea where the text was coming from.
If the text contains an `include` or `import` macro with a relative file name then the file name will be interpreter as relative to the Jamal file and not relative to the file where the snippet came from.
This way, when you write the code of the sippet, you have to know where it will be evaluated.

To avoid this, the macro `snip:eval` should be used.
This macro has three parops to specify the snippet location.
These are:

* `snippet` can specify the snippet to be evaluated.
When this parameter is specified, the other parameters must not be.

* `file` can specify the file name of the tex to be evaluated.
It must be specified if the parop `snippet` is not.

* `line` can specify the line number of the text to be evaluated.
The default value is 1.

When the input of the macro (the text after the parameters, specified between `(` and `)` characters) is empty, then the macro will use the text of the snippet text.
If the input contains text then that text will be evaluated and the `snippet` parameter will only be used for the location.

You may want to use the `snippet` to specify the location and a text when you want to evaluate the snippet after some transformation.
For example, the snippet is part of some JavaDoc, and you want to remove the leading `*` characters from the lines.
In that case yur `snip:eval` can reference the snippet by the name for the file and line number location, but then the actual text is the result of the transformation.

[[snipTransform]]
=== {%chapter%}`snip:transform`
{%#snip:check file={%JAVA_DIR%}SnipTransform.java hash=6994659b%}

The `snip:transform` macro integrates the functionality of the macros

* `kill`
* `skipLines`
* `range` or `ranges`
* `replaceLines`
* `trimLines`
* `reflow`
* `numberLines`
* `untab`

It can kill/keep lines, skip, replace, trim, lines, select line ranges; it can reflow the lines, replace tabs with spaces, and it can number the lines.

{%parameterized%}

The macro implementation itself is calling the underlying other macros, so the functionality what and how it does the above actions are identical.
The purpose of the macro is to provide a shorthand for the common use case of the other macros used together.

The macro is configured with parameters in a similar way as the underlying macros.
The parameters are the same as in those macros, and they are used by the underlying macros the same way.
There are two differences, however.

1. The `snip:transform` macro does not use any user defined macro or option as a parameter.
You cannot, for example, `{@define replace=/foo/bar/}` and hope that `snip:transform` will replace `foo` with `bar`.
You have to use the parameter `replace` as a macro option.

2. There is an extra parameter named `action` (alias `actions`, plural) that lists the actions to perform.

The names for the actions are the followings:

* `kill`
* `skip`
* `range` or `ranges`
* `replace`
* `trim`
* `reflow`
* `number`
* `untab`

If you have a block that you want simultaneously trim and then number the lines, you have to write

{%sample/
{@snip:transform actions=trim,number
         wuff
        line
     Mayak
            Canoe
}
%}

which will result

{%output%}

This is essentially the same as

{%sample/
{#numberLines
{@trimLines
         wuff
        line
     Mayak
            Canoe
}}
%}

eventually with the same result:

{%output%}

The `snip:transform` takes all the actions in the order as they are specified and invokes the macros implementing them passing the parameters.
It is not possible to invoke one action more than once.
Any syntax allowing the separation of the parameters of one execution from another would be complex and probably hard to read.

Some actions have parameters that are the same as the name of the action.
These are `skip`, `range`, `kill`, `trim` and `replace`.
When one of these parameters is specified there may not be a need to specify the action separately.
It is evident that

{%sample/
{@snip:transform kill=A
Apple
Birnen
Birds
Sumatra
}
%}

will delete all lines that contain the uppercase letter `A` and will result:

{%output%}

On the other hand

{%sample/
{@snip:transform pattern=A
 ...
}
%}

does not work, even though the parameter `pattern` is the alias of `kill`.

The following parameters will add the action implicitly to the list:

* `kill` will add the action `kill`
* `keep` will add the action `kill`
* `skip` will add the action `skip`
* `lines`, `range` or `ranges` will add the action `range`
* `replace` will add the action `replace`
* `tab` or `tabSize` will add the action `untab`
* `trim` will add the action `trim`

If an action is already in the list (they are present in the parameter `actions`) they are not added again.
Also, their position remains as specified in the parameter `actions`.
When added, it is in the order as they are listed here in the documentation.
The actual order of the parameters in the macro is irrelevant.
When implicitly added `kill` will always precede `skip` and `replace`.
Likewise `skip` will precede `replace`.

A parameter other than these belonging to an action not listed in the `actions` parameter is an error.
You cannot, for example, specify `width` without adding `reflow` to the actions as it is not readable what the meaning of `width` is without `reflow`.

You will list the action in the `actions` parameter if you want to use it in a different place/order than the one it would get added implicitly.
For example, you want to kill a few lines and also number the lines.
If you do not list the action `kill` then it will be executed after the numbering.
When the lines are deleted, the numbering will have gaps.
It may be your intention, but usually it is not.

[NOTE]
====
The macro `snip:transform` is just a wrapper around the underlying macros.
It first looks up the macros by the name and then invokes them according to the parameters.
It is usually not interesting for the user of the macro.
The underlying macros are implemented in the snippet package, just like `snip:transform` itself.

Jamal, however, makes it possible to redefine built-in macros locally and globally via the `use` macro.
If any of the underlying macros are redefined when the `snip:transform` is invoked, then the actual macro will be invoked.
It also implies that the developers should implement these macros as compatible as the macro of the same name in the snippet package.
They have to implement the `BlockConverter` interface, and their `convertTextBlock()` method should accept the same parameters as their snippet counterpart.
====

The parameters for the `snip:transform` are:

* `action`, (alias `actions`) listing the actions to perform.
* `kill`, (alias `pattern`) passed to `killLines`
* `keep` passed to `killLines`
* `format` passed to `NumberLines`
* `start`  passed to `NumberLines`
* `step` passed to `NumberLines`
* `width` passed to `reflow`
* `replace` passed to `replaceLines`
* `detectNoChange` passed to `replaceLines`
* `skip` passed to `skipLines`
* `endSkip` passed to `skipLines`
* `margin` passed to `trimLines`
* `trimVertical` passed to `trimLines`
* `verticalTrimOnly` passed to `trimLines`
* `tab` or `tabSize` passed to `untab`. Note that the original `untab` parameter is not supported in the `snip:transform` macro.
The reason for that is readability. While `untab size` may be acceptable, it is not clear what the meaning of `size` is in `snip:transform`.
* `lines` (alias `range`, `ranges`) passed to `range`

The meaning and the interpretation of the parameters is the same as for the underlying macros and documented there.

[[lineCount]]
=== {%chapter%}`lineCount`
{%#snip:check file={%JAVA_DIR%}LineCount.java hash=6fe78fb5%}
This macro counts the lines in the content and returns the number of lines in decimal format.

{%sample/
{@lineCount
1
2
3}
%}

results

{%output%}

[[listDir]]
=== {%chapter%}`listDir`
{%#snip:check file={%JAVA_DIR%}ListDir.java hash=f34c4bcb%}
This macro lists the files in a directory and then returns the list of the formatted files.
The format of the macro is:

[source]
----
{@listDir (options) directory}
----

The parameter `directory` can be absolute or relative to the currently processed document.
The options are

* `format` specifying the format of the individual files

* `separator` to specify the separator. The default is `,` (comma).

* `grep` to specify a regular expression to filter the files based on their content.
Only the files that contain a string that matches the `grep` pattern will be listed.

* `pattern` to specify a regular expression to filter the files based on their name

* `maxDepth` is the maximum depth of recursion into subdirectories.
Specify `1` in case you do not want to recurse into subdirectories.

* `followSymlinks` to follow symbolic links

* `countOnly` (alias `count`) returns the number of the files as a string instead of the list of the file names.

The returned names of the files and directories are comma separated by default.
This makes the use of the macro a good candidate to provide the list elements for a `for` loop.
For example,

{%sample/
{#for macroJavaFile in ({@listDir (format=$simpleName) ./src/main/java/javax0/jamal/})=
- macroJavaFile}
%}

will result

{%output%}

The macro `for` is used with the `#` character, so the macro `listDir` is evaluated before executing the `for`.
The listing of the files is recursive and is unlimited by default.
The parameter `maxDepth` can limit the recursion.
The same listing limited to 1 depth (non-recursive) is the following

{%sample/
{#for macroJavaFile in ({#listDir (format=$simpleName) ./src/main/java/javax0/jamal/
{@define maxDepth=1}})=
- macroJavaFile}
%}

will result

{%output%}

The default formatting for the list of the files is the name of the file.
The parameter `format` can define other formats.
This format can contain placeholder, and these will be replaced with actual parameters of the files.
When used in a multivariable for loop, then the format usually has the format

[source]
----
$placeholdes1|placeholder2| ... |placeholder3
----

This is because the `|` character is the default separator for the different values in a `for` macro loop.

The possible placeholders are:

{%#snip:define listDirFormats$formatted=
{%#replaceLines
{%@define replace =`\n`
^\s*"(.*?)".*//\s*(.*)$
* `$1` will be replaced by the $2
OTF
of the file.
TITF
string literal `true` if the file
FO
`false` otherwise.
%}
{%#snip listDirFormats%}%}%}

{%@snip listDirFormats$formatted

* `$size` will be replaced by the size of the file.
* `$time` will be replaced by the modification time of the file.
* `$absolutePath` will be replaced by the absolute path of the file.
* `$name` will be replaced by the name of the file.
* `$simpleName` will be replaced by the simple name of the file.
* `$isDirectory` will be replaced by the string literal `true` if the file is a directory, `false` otherwise.
* `$isFile` will be replaced by the string literal `true` if the file is a plain file, `false` otherwise.
* `$isHidden` will be replaced by the string literal `true` if the file is hidden, `false` otherwise.
* `$canExecute` will be replaced by the string literal `true` if the file can be executed, `false` otherwise.
* `$canRead` will be replaced by the TIFT can be read, `false` otherwise.
* `$canWrite` will be replaced by the string literal `true` if the file can be written, `false` otherwise.
%}

For example,

{%sample/
{!#for (name,size) in ({#listDir ./src/main/java/javax0/jamal/
{@define format=$simpleName|$size}
})=
- name: {`@format /%,d/(int)size} bytes}
%}

will result
{%#snip:define listDir3=
{%output%}%}\

{%@snip listDir3
[source]
----
- jamal: 96 bytes
- snippet: 1,440 bytes
- Snip.java: 2,738 bytes
- SnipSave.java: 4,856 bytes
- Case.java: 2,273 bytes
- NumberLines.java: 2,756 bytes
- RangeMacro.java: 1,240 bytes
- Untab.java: 2,285 bytes
- DateMacro.java: 613 bytes
- Format.java: 930 bytes
- Update.java: 3,754 bytes
- SnipTransform.java: 16,201 bytes
- FilesMacro.java: 5,196 bytes
- Collect.java: 17,685 bytes
- SnipFile.java: 680 bytes
- TrimLines.java: 4,213 bytes
- ThinXml.java: 8,786 bytes
- LineCount.java: 604 bytes
- Replace.java: 1,775 bytes
- SnipLine.java: 691 bytes
- SnipXml.java: 1,489 bytes
- ThinXmlMacro.java: 585 bytes
- BlockConverter.java: 1,822 bytes
- Counter.java: 3,691 bytes
- StringMacros.java: 6,429 bytes
- Clear.java: 434 bytes
- KillLines.java: 1,659 bytes
- SnipLoad.java: 3,530 bytes
- Rot13.java: 907 bytes
- SnippetStore.java: 10,730 bytes
- ListDir.java: 5,583 bytes
- XmlFormat.java: 3,514 bytes
- SnippetXmlReader.java: 6,607 bytes
- XmlInsert.java: 6,177 bytes
- SnipProperties.java: 1,485 bytes
- Xml.java: 1,543 bytes
- CounterMacro.java: 1,811 bytes
- SnipList.java: 1,260 bytes
- XmlDocument.java: 5,656 bytes
- Java.java: 10,404 bytes
- ReplaceLines.java: 2,982 bytes
- SkipLines.java: 2,720 bytes
- SnipCheck.java: 5,866 bytes
- Reflow.java: 1,981 bytes
- Snippet.java: 1,088 bytes
----
%}

If the option `followSymlinks` is used, like in

[source]
----
{@options followSymlinks}
----

then the recursive collection process for collecting the files will follow symlinks.

The separator character between the formatted items is a comma by default.
The option `separator` or its alias `sep` can modify it.
For example the example:

{%sample/
{#listDir (format=$simpleName maxDepth=1 sep=*) ./src/main/java/javax0/jamal/}
%}

will result

{%output%}

[[xmlFormat]]
=== {%chapter%}`xmlFormat`
{%#snip:check file={%JAVA_DIR%}XmlFormat.java hash=6adc6503%}
The macro `xmlFormat` interprets the input as an XML document if there is any, resulting in the formatted document.
If the input is empty or contains only spaces, it registers a post-processor that runs after the Jamal processing and formats the final output as XML.
For example,

{%sample/
{#xmlFormat
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion><name>jamal snippet</name><packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId><artifactId>jamal-snippet</artifactId><version>{%VERSION%}</version>
</project>
}
%}

will result

{%output%}

The default tabulation size is four.
You can alter it by defining the parameter `tabsize`.
For example,

{%sample/
{#xmlFormat
<?xml version="1.0" encoding="UTF-8" standalone="no"?>{@define tabsize=0}
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion><name>jamal snippet</name><packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId><artifactId>jamal-snippet</artifactId><version>{%VERSION%}</version>
</project>
}
%}

will result

{%output%}

As you can see, there is no tabulation in this case.

There is another use of the macro `xmlFormat`.
If you do not include any XML or anything else into the macro as input, the macro will treat this as a command to format the whole output.
It registers itself into the processor, and when the processing is finished, this registered call-back starts.
At that point, it will format the output of the processing.
That way, you can easily format a whole processed file.

The previous example that we used before can also be formulated this way.

{%sample/
{#xmlFormat}
<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
<modelVersion>4.0.0</modelVersion><name>jamal snippet</name><packaging>jar</packaging>
<groupId>com.javax0.jamal</groupId><artifactId>jamal-snippet</artifactId><version>{%VERSION%}</version>
</project>
%}

Note that the macro invocation `{#xmlFormat}` in this case can be anywhere in the input.
The formatting will take place postponed when the processing is finished.
It will result in the same output as before:

{%output%}

The macro can also convert thin XML to normal XML.
Thin XML is the same as normal XML, but the tags start without the `<` character, and the closing tag is omitted.
The actual place of the closing tag is determined by the position of the opening tag.
Whenever a tag line (containing a `>` character after a tag name) or a text line start on a column smaller than the tag tabulation the tag is closed.

To use the thin XML format the parameter `thin` must be specified.

For example:

{%sample/
{#xmlFormat (thin)
project>
  modelVersion>4.0.0
  name>jamal snippet
  packaging>jar
  groupId>com.javax0.jamal
  artifactId>jamal-snippet
  version>{%VERSION%}
  parent>
    groupId>com.javax0.jamal
    artifactId>jamal-parent
    version>1.10.3-SNAPSHOT
    relativePath>../jamal-parent
}
%}

will result

{%output%}

For more examples and detailed explanation of the thin XML format, see the link:./THINXML.adoc[Thin XML Format] page.

[[thinXml]]
=== {%chapter%}`thinXml`

This macro converts thin XML to normal XML.
Although the macro <<xmlFormat,`xmlFormat`>> can also do the conversion it works only for full XML files and not for XML fragments.
If the output is not a full XML then the macro `xmlFormat` may fail.
This macro does only the conversion and does not format the XML or check in any way that the output os correct.
It is useful when you want to convert a thin XML fraction to normal XML.

For example:

{%sample/
{#thinXml
  modelVersion>4.0.0
  name>jamal snippet
  packaging>jar
  groupId>com.javax0.jamal
  artifactId>jamal-snippet
  version>{%VERSION%}
  parent>
    groupId>com.javax0.jamal
    artifactId>jamal-parent
    version>1.10.3-SNAPSHOT
    relativePath>../jamal-parent
}
%}

will result

{%output%}

As you can see in this example the output is not a full XML file.
It is not formatted also and there is no leading ```<?xml version="1.0" encoding="UTF-8" standalone="no"?>``` line.

For more examples and detailed explanation of the thin XML format, see the link:./THINXML.adoc[Thin XML Format] page.

[[date]]
=== {%chapter%}`date`
{%#snip:check file={%JAVA_DIR%}DateMacro.java hash=92b8d56d%}
This macro will return the current date formatted using Java `SimpleDateFormat`.
The format string is the input of the macro.

Example

{%sample/
{@date yyyy-MM-dd HH:mm:ss}
%}

will result in the output

{%#snip:define dateOutput={%output%}%}\
{%@snip dateOutput%}

[[format]]
=== {%chapter%}`format`
{%#snip:check file={%JAVA_DIR%}Format.java hash=4bb6050d%}
You can use the macro `format` to format the arguments.
{%standardInput%}

The first argument will be interpreted as the format string.
The rest of the arguments will be used as the values for the formatting.
By the nature of Jamal, all these arguments are strings.
Since the parameters to the underlying `String::format` method are not only strings, they can be converted.
If any of the parameters starts with a `(xxx)` string, then the string will be converted to the type`xxx` before passing to `String::format` as an argument.
This format is similar to the cast syntax of Java and C.

The `xxx` can be

{%!@for type in (int,long,double,float,boolean,short,byte)=
* `type`, the conversion will call {%#case:cap {%@replace (detectNoChange=false)/type/int/integer%}%}::parse{%@case:cap type%}.%}
* `char`, the conversion will fetch the first character of the parameter.

Examples:

{%sample/
{@define LONG=5564444443455587466}
{@format /%,016d/(int)  587466}
{#format /%x/(long){LONG}}}
{@format /%,016.4f/(double)587466}
{@format /%e/(double)587466}
{@format /%e is %s/(double)587466/5.874660e+05}
{#format /hashCode(0x%x)=0x%h/(long){LONG}/(long){LONG}}
%}

will result in the output

{%#snip:define formatOutput={%output%}%}\
{%@snip formatOutput
[source]
----
000000000587,466
4d38e0bd5891048a}
0000587,466.0000
5.874660e+05
5.874660e+05 is 5.874660e+05
hashCode(0x4d38e0bd5891048a)=0x15a9e437
----
%}

[[numbers]]
=== {%chapter%}`numbers`

{%!@snip numbers%}

[[unicode]]
=== {%chapter%}`unicode`

{%!@snip unicode%}

[[case]]
=== {%chapter%}`case:lower`, `case:upper`, ...
{%#snip:check file={%JAVA_DIR%}Case.java hash=28aa6570%}
There are a few character-case changing macros implemented in the snippet package.
These are:

{%@define case(lower)=* `case:lower` changes the characters in the input to lower case letters%}
{%case lower%}
{%case upper%}
{%@define case(cap,upper)=* `case:cap` changes the first character in the input to upper case letter%}
{%case/cap/upper%}
{%case/decap/lower%}

{%CH/locate/file:locate%}

{%CH/dev_root/dev:root%}

[[file]]
=== {%chapter%}`file`
{%#snip:check file={%JAVA_DIR%}FilesMacro.java hash=3ca91fb6%}
{%@define fileDirectory($what)=
You can use this macro to include the name of a $what in the documentation.
First, it seems counterintuitive to have a macro for that.
You can type in the name of the $what, and it will appear in the output.

The real added values of the macro are that

* it checks that the $what exists, and
* it can format the name of the $what.

The macro will error if the $what does not exist or is not a $what.
It helps the maintenance of the documentation.
If the $what gets renamed, moved, or deleted, the document will not compile until you follow the change.

The macro can also format the name of the $what.
It uses the value of the user-defined macro `$whatFormat` for the purpose.
If this macro is defined outside the `$what` macro, then the $what names will be formatted using the same format.
For example, you can write%}\
{%fileDirectory file%}

{%sample/
When Jamal processes this file it will generate {@file (format=`$name`)README.adoc}.
%}

will result

{%output%}

{%@define FILE_PAROPS($what)=
The macro `$what` has the following parameters:

* `format` can define the format of the name of the $what.
   In the format you can use placeholders starting with `$`.
   For the list of the placeholders see the documentation below.
* `root` can specify the directory where the $what is.
  This parameter is prepended in front of the $what name.
  The default value is an empty string.
* `dateFormat` can specify the format to display the date and time when the format uses one of the time placeholders.
   The default value is `yyyy-MM-dd HH:mm:ss`.
* `relativeTo` can specify a file or directory to which the output should be relative to when the placeholder `$relativePath` is used in the format.
   The default value is the directory where the top level file is.

[NOTE]
====
The formatting `$relativePath` is useful when you have a Jamal file which is a document in its own, and it is also included in another document.
Having a `link` in the file should be relative to the document on the top level, including directly or through other files the one containing the link.
The placeholder `$relativePath` will generate a relative file name, which is relative to the actual top level document.
====

%}
{%FILE_PAROPS(file%}

In the format you can use the following placeholders:
{%@comment the two replace commands are executed from left to right. The first one puts a ! after the `xxx` name, and the second one finds it.%}

{%@snip (replace="|^.*?\"(.*?)\"|* `$1`! <- this is found and replaced by the second 'replace'|"
         replace="|!.*?//||")

         fileMacroFormatPlaceholders
%}

{%@define SUPPORT_ROOT($what)=
When the placeholder `$time`, `$ctime`, or `$atime` is used the time will be formatted as `yyyy-MM-dd HH:mm:ss` by default.
This format can also be changed by defining the macro/option `dateFormat`.

The macro also supports the option `root`.
This can be used to define the root directory for the $whats' location.
The usual use is to define `root` as a global macro and all `$what` macros should use file names relative to that following the definition.
This may save some time when you are referring to many files in a deep directory structure relative to the document file.%}{%SUPPORT_ROOT/file%}

[[directory]]
=== {%chapter%}`directory`
{%#snip:check file={%JAVA_DIR%}FilesMacro.java hash=3ca91fb6%}
{%fileDirectory directory%}

{%sample/
This file is in the directory {@define directoryFormat=`$name`}{@directory ../jamal-snippet}.
%}

will result

{%#snip:define dirOutput={%output%}%}\
{%@snip dirOutput
[source]
----
This file is in the directory `../jamal-snippet`.
----
%}

{%FILE_PAROPS(directory%}

In the format you can use the following placeholders:
{%#snip:define fileMacroFormatPlaceholdersFormatted=
{%@snip (replace="|^.*?\"(.*?)\"|* `$1`!|!.*?//||") fileMacroFormatPlaceholders %}%}

{%#replace (detectNoChange)|{%@snip fileMacroFormatPlaceholdersFormatted%}|file|directory%}

{%SUPPORT_ROOT/directory%}

[[Java]]
=== {%chapter%}Java Macros
{%#snip:check file={%JAVA_DIR%}Java.java hash=88b7a841%}

[[java:class]]
==== `java:class`

{%@define classMethodMacroIntro($x)=
The macro `java:$x` checks that the parameter is a valid Java $x and found on the classpath.
It is an error if the class is not on the classpath.
This macro is useful when you document Java source code and run the Jamal conversion from a unit test.
In this case, the macro will see the test and main classes.
It can check that the $x mentioned in the documentation is still there; it was not deleted or renamed.

When you run the conversion outside the code of the documented program, the $x is not on the classpath.
You can use the `java:sources` macro to include the source code as well as the compiled byte codes in the documentation to overcome this limitation.
It is typically the case when you use IntelliJ and Asciidoctor plugin.

Note that the Java compiler may not be available in the JRE executing the IntelliJ editor.
In this case, the macro will find the class if you also specify the compiled classes using the parameter `classes` to the macro `java:sources`.

%}\
{%classMethodMacroIntro class%}

The output of the macro is the class formatted.
The formatting is the simple name of the class by default.
The formatting can be defined by the parameter `classFormat`.
For example:

{%sample/
The class that implements the macro `java:class` is
{@java:class javax0.jamal.snippet.Java$ClassMacro}.
%}

will result in the output

{%#snip:define class1={%output%}%}\
{%@snip class1
[source]
----
The class that implements the macro `java:class` is
ClassMacro.
----
%}

The format string can be any string with `$` prefixed placeholders.
The placeholders that the macro handles are:

{%#replaceLines replace="/^\\s*\"\\$(.*)\"\\s*,?/* `\\$$1` will be replaced by the result of calling `$1()`"
{%@snip classFormats%}%}

For example

{%sample/
The class that implements the macro `java:class` is
{@define classFormat=$canonicalName}\
{@java:class javax0.jamal.snippet.Java$ClassMacro} with the canonical name, and
{@define classFormat=$name}\
{@java:class javax0.jamal.snippet.Java$ClassMacro} with the "normal" name.
It is in the package {#java:class javax0.jamal.snippet.Java$ClassMacro {@define classFormat=$packageName}}
{@java:class javax0.jamal.snippet.Java$ClassMacro} is still the "normal" name,
format defined inside the macro is local.
{@java:class (format="$simpleName") javax0.jamal.snippet.Java$ClassMacro} is the simple name.
%}

will result in the output

{%#snip:define class2={%output%}%}\
{%@snip class2
[source]
----
The class that implements the macro `java:class` is
javax0.jamal.snippet.Java.ClassMacro with the canonical name, and
javax0.jamal.snippet.Java$ClassMacro with the "normal" name.
It is in the package javax0.jamal.snippet
javax0.jamal.snippet.Java$ClassMacro is still the "normal" name,
format defined inside the macro is local.
----
%}

It is not recommended to overuse the format string.
Do not include verbatim text into the format string.
Choose a format string you want to refer to the classes and use it globally in the document.

[[java:field]]
==== `java:field`

{%classMethodMacroIntro field%}
In addition to that the value of the value of the field can also be used in the formatting in case the field is both `static` and `final`.
{%sample/
{@define field=javax0.jamal.api.SpecialCharacters#PRE_EVALUATE}
The field {#java:field (format="$name") {field}}
defined in the class {#java:field (format="$className") {field}}
is both `static` and `final` and has the value {#java:field (format="$value") {field}}
%}

will result in the output

{%output%}

The format string can be any string with `$` prefixed placeholders.
The placeholders that the macro handles are:
{%@define replace=`\n`
^.*?"(.*?)".*//\s*(.*)$
* `$1` will be replaced by the $2
OTFDC
of the fields' defining class
OTF
of the field
%}
{%#snip:define fieldFormatFormatted={%#replaceLines
{%@snip fieldFormats%}%}%}
{%@snip fieldFormatFormatted%}

[[java:method]]
==== `java:method`

{%classMethodMacroIntro method%}

The output of the macro is the method formatted.
The formatting is the name of the method by default.
The formatting can be defined by the parameter `methodFormat`.
For example:

{%sample/
{@define method=/javax0.jamal.snippet.Java$MethodMacro/evaluate}\
{#java:method {method}}
%}

will result in the output

{%#snip:define method1={%output%}%}\
{%@snip method1
[source]
----
evaluate
----
%}

The macro can have two arguments, using the link:../README.adoc#argsplit[Standard Built-In Macro Argument Splitting] or one, specifying the full name of the method.
The method's full name is the class's full name, and the method name separated by either a `#` character or by `::` characters.

The format string can be any string with `$` prefixed placeholders.
The placeholders that the macro handles are:
{%@define replace=`\n`
^.*?"(.*?)".*//\s*(.*)$
* `$1` will be replaced by the $2
OTMDC
of the method's defining class
OTM
of the method
%}
{%#replaceLines
{%@snip methodFormats%}%}
These formats can be used in your macros directly or using the macros defined in the jim file `res:snippet.jim`.
For example,

{%sample/
The class that implements the macro `java:method` is '{#java:method {method}{@define methodFormat=$name}}()',
but it is simpler to import the jim file included in the snippet library

            {@import res:snippet.jim}\

and use the user defined macros, like the following:

{java:method:modifiers |{method}}\
{java:method:classSimpleName |{method}}\
::{java:method:name |{method}}({java:method:parameterTypes:simpleName |{method}})
%}

will result in the output

{%#snip:define method2={%output%}%}\
{%@snip method2
[source]
----
The class that implements the macro `java:method` is 'evaluate()',
but it is simpler to import the jim file included in the snippet library


and use the user defined macros, like the following:

publicMethodMacro::evaluate(Input,Processor)
----
%}

[[java:sources]]
==== `java:sources`

This macro will read Java sources, compile them and make them available for the other macros.
Think of this macro as a location declaration of the Java files documented.
You can specify the location of the source code as well as the location of the compiled class files.
To do that, the macro has four parameters:

* `src` is the location of the source files. It is also aliased as `source` and `sources`.
* `class` is the location of the compiled class files. It is also aliased as `classes`.
* `store` can specify the name of the macro holding the loaded classes.
See details below.
* `options` aliased as `compilerOptions` can specify the options passed to the Java compiler.
You can use this parameter to pass options like `-cp` or `-classpath` to the compiler.

{%@define NOPAREN=
Since the macro does not use its input, the parameters can be specified in the macro call without enclosing them between parentheses.%}{%NOPAREN%}

The macro will first try to compile the source files.
It will try to load the classes from the class files if the compilation fails for any reason.

Jamal may be running with a JDK that provides a Java compiler instance for Java.
This is the case when Jamal is executed from the command line, from a Maven extension, etc.
Executing Jamal inside IntelliJ as an Asciidoctor plugin preprocessor may not provide a Java compiler.
The compilation may also fail when there are external dependencies needed for the compilation.

If there is no source location defined or there is no compiler available, then the macro will load the already compiled classes.
In other cases, the macro will read the source files, compile them and load the classes for the macros to use.

NOTE: Compiling the source code may need significant resource.
You may consider omitting the `src` parameter if you use the macros only for class, method and field names formatting.
On the other hand, when you use the macros for code generation, you may stick to the source code.
(See also the <<java:insert,`java:insert`>> macro.)
In those situations, the compiled code, before the code generation, may be out of date or even unavailable when Jamal is executed as part of the compilation.

When the classes are loaded form the compiled class files, it may happen that not all classes are loaded.
For example, if a class extends a library class or interface, not provided as source code, then class loading will fail for that class.
The other classes will, however, still be loaded, and the macros will be able to use them.

This macro has a third option named `store`.
When the classes are loaded they are stored in a user defined macro named `{%@snip LOADED_CLASSES%}`.
You can load different sets of class files providing a different name in this parameter.
This parameter can also be used in the macros

* <<java:classes,`java:classes`>>
* <<java:methods,`java:methods`>>
* <<java:fields,`java:fields`>>

but not in

* <<java:class,`java:class`>>
* <<java:method,`java:method`>>
* <<java:field,`java:field`>>

The plural versions are used for code generation.
The singular versions are used for formatting and will always use the classes in the executing JVM or those loaded to the default macro class store.

[[java:classes]]
==== `java:classes`

This macro will return the list of selected classes.
The classes have to be loaded first using the <<java:sources,`java:sources`>> macro.
The macro has three parameters:

{%@define STORE=* `store` can specify an alternative user defined macro where the classes are stored.
Use this option specifying the same name as in the macro <<java:sources,`java:sources`>>.
It is recommended not to use this option.
%}{%STORE%}
{%@define SELECTOR($x)=* `selector`, aliased as `only`, and `filter` should be used to filter the $x.
The value of this parameter is a selector expression.
This selector expression is interpreted by the tool REFI as documented `https://github.com/verhas/refi`.
%}{%SELECTOR/classes%}
{%@define SEP($x)=* `sep`, aliased as `separator` canbe used to specify the separator string between the $x.
The default value is comma, which makes the result usable in a `for` macro.
Do not forget to use the `[evalist]` option when using in the `for` macro the result of this macro.
%}{%SEP/classes%}
{%NOPAREN%}

The returned list will contain the names of the classes.

[[java:methods]]
==== `java:methods`

This macro will return a list of selected methods.
The macro has four parameters:

{%STORE%}
{%SELECTOR(methods)%}
{%@define CLASS($x)=* `class` can be used to specify a selector for the classes where the $x are to be selected from.
%}{%CLASS/methods%}
{%SEP(methods)%}

{%NOPAREN%}

The methods will be stored in user-defined macros.
The returned string is the name of the macro where the methods are stored.
These macros can be evaluated.
The macro will interpret the first argument as a formatting command and will return

* `class` will result the name of the class the method is declared in

* `name` will result the name of the class.
This is also the case when there is no parameter defined.

* `modifiers` will return the modifiers of the method.

* `modifiers-abstract` will return the modifiers of the method, minus the `abstract` modifier if there was such.

* `exceptions` will return the list of the exceptions the method throws.

* `args` will return the list of the arguments of the method.

* `call` will return the method call with the arguments.

* `callWith` will return the method call with the arguments provided in the macro.

* `type` the return type of the method.

* `signature` the signature of the method.
This formatting also interprets the following parameters as:

** `concrete` will return the signature of the method without the `abstract` modifier if there was such.
** `abstract` will return the signature of the method with the `abstract` modifier if there was such.
** `interface` will return the signature of the method without the `public` modifier, so it can be used in an interface.
** `public` will return the signature of the method with the `public` modifier, even if the original method was not public


[[java:fields]]
==== `java:fields`
This macro will return a list of selected fields.
The macro has four parameters:

{%STORE%}
{%SELECTOR(fields)%}
{%@define CLASS($x)=* `class` can be used to specify a selector for the classes where the $x are to be selected from.
%}{%CLASS/fields%}
{%SEP(fields)%}

{%NOPAREN%}

The fields will be stored in user-defined macros.
The returned string is the name of the macro where the fields are stored.
These macros can be evaluated.
The macro will interpret the first argument as a formatting command and will return

* `class` the class name the field is declared in.

* `name` the name of the field.
This is also the case when there is no parameter defined.

* `modifiers` the modifiers of the field.

* `modifiers-abstract` the modifiers of the field, minus the `abstract` modifier if there was such.

* `type` the type of the field.


[[java:insert]]
==== `java:insert`
{%#snip:check file={%JAVA_DIR%}JavaSourceInsert.java hash=95fdeecd%}

The macro `java:insert` can be used to insert the content of the macro into a Java source file into a segment.
The macro has three parameters:

* `file` Is the name of the file where the segment is to be inserted.
It is also aliased as `to` and `into`.

* `segment` is the name of the segment where the content is to be inserted.
It is also aliased as `id` and `at`.
This parameter is optional and is not needed if there is only one segment in the file.

* `check`, `checkUpdate`, `update`, `updateOnly` will do an extra step before updating the file.
It will do a lexical analysis on the original file and on the new version and compare the two.
If they are the same on the Java lexical level ignoring differences in comments and white-space, then the file is not updated.

+
This is useful not to ruin the already generated code when it was formatted and does not change other than that.
It can also be used when the build process runs in properly configured a CI/CD environment where the build process cannot write the source files.
In that case, the developer builds should update the source code, and the CI/CD process can see the already updated code.

+
The downside is that the comparison needs time and some memory.

* `failOnUpdate`, `failUpdate`, `updateError` will result an error if the file is updated.
Note that the processing will not stop, only the macro will result in an error at the end of the Jamal file processing.
If there are multiple `java:insert` macros in the file, then all of them will be processed the error will only happen at the end of the processing.
This option may be useful in a build process when the code generation runs after the compilation.
If the code was updated, then the compilation should fail.
The code, however, was already updated and the compilation started again will be successful.

* `wholeFile` is a boolean option.
If it is present then no segment should be, and the whole file will be updated, all the lines.
In this case it is not an error if the file does not exist yet.

The parameters are not enclosed between any characters.
They follow the macro name directly until the end of the line.

{%sample/
{@java:insert update to="Sample.java" id="segment"}
%}

The segment in the source file starts with a line

  //<editor-fold id="segment"...>

and it ends with

    //</editor-fold>

If there are lines between these two lines, they are deleted and replaced by the input of the macro.

If the macro input is empty, then the file writing is deferred until the end of the processing.
In this case, the content of the whole output is going to be used.

[NOTE]
====
When the macro writes its' input into the file, you will most probably want to use `#` as macro character.
That way, the input will be first processed.

The suggested practice is to name the file `XYZ.java.jam` for code to be inserted into `XYZ.java`.
Do not forget to add ``{%@escape*`.`{%@comment nosave%}`.`%}`` to the beginning of the file.
This will prevent the Asciidoctor version of Jamal overwriting the Java file when editing the macros.
====

[[String]]
=== {%chapter%}String Macros
{%#snip:check file={%JAVA_DIR%}StringMacros.java hash=562fe9cf%}

[[string:contains]]
==== `string:contains`

This macro returns the string `true` if the input contains a text given as a parameter and the text `false` otherwise.
The macro handles two parameters:

* `text` {%alias string%} must be present, and it should specify the string to find in the input.

* `regex` is an optional parameter.
If it is `true`, then the text will be interpreted as a regular expression.
The macro will check if a match is found inside the input.
(It calls the Java regular expression matcher `find()`.)

[[string:quote]]
==== `string:quote`

This macro returns the input of the macro quoted.
You can use the string inside another string that way.
This macro is useful when the output is used as some programming language source.
Example:

{%sample/
{@string:quote This "is" quoted '
 new line is also quoted, tabs are also and line-feed also \ becomes doubled}
%}

will result

{%output%}

The actual conversions performed are:

* `\` -> `\\`
* tab -> `\t`
* back space -> `\b`
* new line -> `\n`
* line feed -> `\r`
* form feed -> `\f`
* `"` -> `\"`

[[string:equals]]
==== `string:equals`

This macro returns the string literal `true` or `false` comparing the two arguments.
It returns `true` if the two arguments are equal and `false` otherwise.
If the option `ignoreCase` is used, then the comparison is made ignoring the character casing.

Example:

{%sample/
{@string:equals/aaa/aaa}
{@string:equals/aaa/bbb}
%}

will result

{%output%}


[[string:startsWith]]
==== `string:startsWith`

This macro returns the string literal `true` or `false` comparing the two arguments.
It returns `true` if the first argument starts with the second argument and `false` otherwise.

Example:

{%sample/
{@string:startsWith/aaa/aa}
{@string:startsWith/aaa/ba}
%}

will result

{%output%}

[[string:endsWith]]
==== `string:endsWith`

This macro returns the string literal `true` or `false` comparing the two arguments.
It returns `true` if the first argument ends with the second argument and `false` otherwise.

Example:

{%sample/
{@string:endsWith/aaa/aa}
{@string:endsWith/aaa/ab}
%}

will result

{%output%}

[[string]]
==== `string`

This macro can perform the operations `startsWith`, `endsWith`, `equals`, and `contains`.
The macro has three parameters:

* the string the operation is performed on,
* the operation to perform,
* the string to compare to.

The operation has to be given by the names `startsWith`, `endsWith`, `equals`, `equalsTo` or `contains`.
The name of the operation is case-insensitive.

The macro also handles the parop `ignoreCase`.
When using this alternative format of the comparison, then all operations use this parameter.

[[string:reverse]]
==== `string:reverse`

This macro returns the reverse of the input string.
For example:

{%sample/
{@string:reverse 0123456789abcdefgh}
%}

will result

{%output%}

[[string:substring]]
==== `string:substring`

This macro returns a substring of the input.
The parameters are

* `begin` specifying the beginning of the substring (default is the start of the string), and

* `end` specifying the end of the substring (default is the end of the string).

If any of the parameters is a negative number, then the macro calculates the position from the end of the string.

Examples:

{%sample/
{@string:substring the whole string}
{@string:substring (begin=0 end=3)the first three character} only the'
{@string:substring (begin=1 end=-1)ythea}
%}

will result

{%output%}

[[string:between]]
==== `string:between`

This macro extracts a substring from the input, confined between two specified strings. The parameters are:

- `after`: Specifies the string after which the substring should begin. By default, the substring starts at the beginning of the input string if this parameter is not provided.
- `before`: Specifies the string before which the substring should end. By default, the substring extends to the end of the input string if this parameter is not provided.

The behavior of the macro under different conditions is as follows:

1. If the `after` string is not found in the input, the macro returns an empty string.
2. If the `before` string is not found in the input, the macro also returns an empty string.
3. If the `after` string appears more than once in the input, the macro selects the substring starting after the first occurrence of the `after` string.
4. If the `before` string appears more than once in the input, the macro selects the substring ending before the last occurrence of the `before` string.
5. If the last occurrence of the `before` string is positioned before the first occurrence of the `after` string in the input, the macro returns an empty string.

This macro is useful for parsing strings where specific delimiters define the boundaries of the desired content. For example, the macro can be used to extract the content of a JavaDoc comment:

{%sample/
{@string:between (after="/**" before="*/")/** This is a JavaDoc comment. */}
%}

will result in

{%output%}

[[string:before]]
[[string:after]]
==== `string:before`, `string:after`

These macros extract a portion of the input string, starting before or after a specified occurrence of a given substring.
They are highly configurable, allowing for precise control over which occurrence to consider and how to handle case sensitivity.
The two macros are implemented as a single macro, which alters the behaviors depending on the alas (`string:after` or `string:before`) used to invoke it.
The behaviour can be controlled using paops.

Parameter options (parops):

* `first`/`theFirst`, `second`/`theSecond`, `third`/`theThird`, `last`/`theLast`, `nth`/`theNth` specifies the searched string and which occurrence of the substring to consider.
You can indicate a specific occurrence like `first`, `second`, `third`, or use `nth` to specify any occurrence.

* `n` is used in conjunction with `nth`/`theNth` to specify the nth occurrence of the substring.

* `fromEnd`/`fromTheEnd` When set, the search for the specified occurrence of the substring starts from the end of the string.
Cannot be used together with `first`/`theFirst`, or `last`/`theLast`.
Instead of using `fromEnd` and `last` you can use `first`.
Similarly, instead of using `fromTheEnd` and `first` you can use `last`.

* `ignorecase`/`ignoreCase`: When set, the search is case-insensitive.

When the substring is not found, or there are less number of occurences than required, the resutn value is empty string.

Examples:

{%sample/
{@string:after (second="a") alabala bim bam bum}
%}

will result in

{%output%}

{%sample/
{@string:before (theThird="a") alabala bim bam bum}
%}

will result in

{%output%}

{%sample/
{@string:before (theSecond="A" ignoreCase fromEnd) alabala bim bam bum}
%}

will result in

{%output%}

[[string:length]]
==== `string:length`

This macro returns the length of the input.
The parameters are:

* `trim` tells the macro that the input has to be trimmed before calculating the length

* `left` tells the macro that the trimming has to be applied to the start (left) of the input

* `right` tells the macro that the trimming has to be applied to the end (right) of the input

You can use `left` and `right` together with `trim`.
It will have the same effect as using `trim` alone.
Using either `left` or `right` without trim is an error.

[[string:chop]]
==== `string:chop`

Chop off a substring from the start or from the end of the input.
The parameters are:

* `prefix`, `pre` or `start` can specify a string that the input may start with. If the input starts with this string, it will be removed.
* `postfix`, `post` or `end` can specify a string that the input may end with. If the input ends with this string, it will be removed.

* `ignorecase` or `ignoreCase` tells the macro that the strings are case-insensitive.

[[shell:var]]
=== {%chapter%}`shell:var`

This macro is a convenience tool replacing `$variable` and `pass:[${variable}]` sequences with the values of the variables.
The values of the variables can be provided and looked up from

* macro parameters in the string of the value of the parameter `variables`,
* macros defined,
* Java system variables,
* environment variables,

in this order.

{%sample/
{@define A=value}
{@shell:var $A}

%}

results in

{%output%}

The variable replacement is performed recursively.
If there is a variable reference in the result, then it will be replaced again.
Also, when the reference is `pass:[${string}]` formatted the `string` is first processed for variables.
This processing is done 100 levels deep.
If the macro detects a loop, then it will stop the processing and results in a `BadSyntax` exception.

Although `$` is a valid character in a macro name, you cannot reference a macro that has a $ in its name.
Also, the macro must not require any parameter.

[[hashCode]]
=== {%chapter%}`hashCode`
{%#snip:check file={%JAVA_DIR%}HashCode.java hash=7742f9d6%}

This macro returns the hash code of the macro input as a 64-character hexadecimal string.

{%sample/
{@hashCode abraka dabra}
%}

will result in

{%output%}

[[memoize]]
=== {%chapter%}`memoize`

{%!@snip Memoize%}


[[download]]
=== {%chapter%}`download`

{%!@snip Download%}

[[snip_update]]
=== {%chapter%}`snip:update`
{%#snip:check file={%JAVA_DIR%}Update.java hash=917df28d%}
This macro was used to automatically copy the content of the snippets into the `snip` macros.
It meant to update the edited source document.
It was a temporary woraround till the time when the WYSIWYG editor was not available in IntelliJ.
Since the introduction of the WYSIWYG editing in IntelliJ, this feature is outdated.

To keep backward compatibility the `.jim` resource file contains the line:

  {@use global comment as snip:update}

{%@snip:update this is comment%}

This renders the current, no operation functionality of the macro.

{%CH /variation/variation%}

{%CH /plural/plural%}

[[dictionary]]
=== {%chapter%}`dictionary`

This macro can be used to define a dictionary.
Dictionaries are used by the decorator macro, but other macros can also use them.
A dictionary is a set of words associated with a position inside the word.
The macro input consists of the words separated by new lines.
Each word can have a position specified after the word separated by a non-letter character.
For example, the dictionary:

{%sample/
{@dictionary
  a.braka
  da.bra
  bubabo.
  .sholano
  molano
}%}

will define the word `abraka` with the position `1`, the word `dabra` with the position `2`, the word `bubabo` with the position `6`, the word `sholano` with the position `0` and the word `molano` with the position `6`.
The position is denoted using a dot in this example, but you can use any non-letter character.

The macro has one parameter `id` or `name` that specifies the name of the dictionary.
The default name is `{%@snip DEFAULT_DICTIONARY_NAME%}`.
This is also the default name of the dictionary used by the <<decorate,`decorate`>> macro.


[[decorate]]
=== {%chapter%}`decorate`

This macro can be used to decorate a text.
The decoration happens for each word separately.
You can use this to make the text more appealing, or less readable used for obfuscation.

The decoration first splits the input into words.
The words are separated by non-letter characters.
The non-words and words, which are delimited by special characters (see below), are not decorated.

The decoration of the words is done in two steps.
The first step splits the word into parts.
The second step decorates the parts individually.

Decoration is done by user-defined macros.
These macros should have exactly one argument.
For example, the macro

{%sample/
{@define decor(x)={@rot13 x}.}
%}{%#comment {%output%}%}

will decorate the input by ROT13 encoding.
After this, the decoration macro can be used as

{%sample/
{@decorate (decorator=decor)abraka dabra}
%}

resulting in

{%output%}

The macro has the following parameters between `(` and `)`:

* `decor$delimiters` aliased as `delimiters` defines the delimiter strings that surrounding a word make them not decorated.
The default value is `"pass:[{%@snip DEFAULT_DELIMITERS%}]"`.
It means that any word delimited by `~`, `_` oe `[` and `]` will not be decorated.
The first character of the string is used to separate the strings that follow.
Note that the default value uses single characters, but you can use any string as a delimiter.

* `decorator` defines one or more macros used as decorators.
You can repeat this option multiple times.
When a word is split into multiple parts, the first part will be decorated using the first decorator, the second part using the second, and so on.
The default decorator puts a space after the decorated part.
The words will be split into no more parts than the number of decorators plus one.
In this case, the last part of the word will not be decorated.

* `repeat` is a boolean parameter.
If it is present on the macro splitting will be repeated as many times as needed.
Without this option, the words will be split into two parts at most, or to as many parts as the number of decorators.

* `decor$ratios` aliased as `ratios` defines the number of characters and the ratio of the characters used to split the word.
The default value is `"pass:[{%@snip DEFAULT_RATIOS%}]"`.
The first character is either '-' or '+' signaling if common words should be decorated or not.
Common words can be defined in a <<dictionary,`dictionary`>> or are defined as {%@snip DEFAULT_COMMON_WORDS%}.
+
The following integers define the number of characters used to split the word if the word is 1, 2, 3 and so on characters.
+
The last number defines the ratio of the characters used when the word is longer than the last number position. In the example above, one character words will not be split, two and three character words will be split after the first character, four character words will be split after the second character. Any word longer than four characters will be split at 40%.
+
The last number will be rounded to two decimals.

* `decor$dictionary` aliased as `dictionary` or `dict` defines the name of the dictionary used to define words with predefined splitting position.
If this option is not present the macro will try to use the dictionary named `{%@snip DEFAULT_DICTIONARY_NAME%}`.
If this dictionary does not exist, the macro will use the default splitting position defined by the `decor$ratios` option and the postfixes.
If this option is defined, the dictionary named must exist.

* `decor$pfDict` aliased as `ending`, `endings`, `pf` defines the postfix dictionary.
When a word ends with a word present in the postfix dictionary, the word will be split earlier or at last at the start of the postfix.
If the option is not present a default set of postfixes will be used:
{%@snip DEFAULT_POSTFIXES%}.

* `decor$cmDict` aliased as `common`, `commons`, `cm` defines the common words' dictionary.

{%chapter close%}{%@undefine chapter$format%}
[[kroki]]
=== {%chapter%}Kroki

In this section, we will describe how to utilize the snippet handling macros in conjunction with the Kroki service.

The Kroki service is a free online platform capable of rendering diagrams from a text.
Users can utilize the public service or to install the application on-premises.
Although we will focus on using the public service in this section, the process for an on-premises installation is very similar.

The service's documentation and the types of diagrams it supports are accessible at [https://kroki.io/](https://kroki.io/).

Kroki provides direct support for incorporating generated images into AsciiDoc and Markdown documents.
Within this module, there is a resource file named `kroki.jim`.
You can integrate this file into your document by using `{@import res:kroki.jim}` and employ the macro defined within.

The `kroki` macro requires four parameters:

1. The name of the diagram, which will be utilized to title the generated image file.
2. The diagram type, which can be any type supported by the Kroki service in use.
3. The file type, options include `png`, `svg`, `jpeg`, etc. This parameter will not only be relayed to the Kroki service but also used as the file name extension.
   The various file types that are supported are documented at [https://kroki.io/](https://kroki.io/).
4. The diagram text.

The macro encodes the diagram text, transmits it to the Kroki service, downloads the generated image, and embeds it into the document.
If the including file's name ends with `md.jam`, the macro will employ Markdown syntax for the image. Otherwise, it will use AsciiDoc syntax.

Should you require a different syntax, the `kroki:download` macro is available.
This macro accepts the same arguments and returns the file name of the downloaded image.

These macros generate image files named according to the provided name and append the file type as an extensions.
Additionally, they create a file with the same name and an extra `.hash` extension.
The macro will only call the web-based service if the image file does not exist or if the diagram text has changed since the last execution.
It may be beneficial to include these files in your source repository to minimize unnecessary network traffic on the CI/CD server.